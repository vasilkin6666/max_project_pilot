# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–∞–ø–∫–∏: E:\GUAP\max_project_pilot\bot

## –î–µ—Ä–µ–≤–æ –∫–∞—Ç–∞–ª–æ–≥–æ–≤

```
bot/
  Dockerfile
  app/
    __init__.py
    bot.py
    config.py
    handlers/
      __init__.py
      notifications.py
      projects.py
      start.py
    services/
      __init__.py
      api_client.py
    utils.py
  requirements.txt
```

## –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–æ–≤

### Dockerfile

```txt```
# bot/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "-m", "app.bot"]

```

### requirements.txt

```txt```
maxapi==0.9.7
requests==2.32.3
python-dotenv==1.0.1
loguru==0.7.2
aiohttp>=3.12.14
pydantic-settings>=2.0.0
pydantic>=2.0.0

```

### app\__init__.py

```py```
# bot/app/__init__.py
# –≠—Ç–æ—Ç —Ñ–∞–π–ª –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –±–∞–∑–æ–≤—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ø–∞–∫–µ—Ç–∞ app

```

### app\bot.py

```py```
# bot/app/bot.py
import asyncio
from maxapi import Bot, Dispatcher, F
from maxapi.types import MessageCreated, MessageCallback
from maxapi.filters.command import Command

from app.config import settings
from app.handlers import (
    cmd_start, cmd_create_project, cmd_join_project,
    handle_callback_create_project_start,
    handle_callback_projects,
    handle_callback_project_summary,
    handle_callback_project_invite,
    handle_callback_project_requests,
    handle_callback_notifications
)

bot = Bot(token=settings.BOT_TOKEN)
dp = Dispatcher()

@dp.message_created(Command('start'))
async def handle_start(event: MessageCreated):
    await cmd_start(event)

@dp.message_created(Command('create_project'))
async def handle_create_project(event: MessageCreated):
    await cmd_create_project(event)

@dp.message_created(Command('join'))
async def handle_join_project(event: MessageCreated):
    await cmd_join_project(event)

@dp.message_callback(F.callback.payload.startswith("projects"))
async def handle_projects_callback(event: MessageCallback):
    await handle_callback_projects(event)

@dp.message_callback(F.callback.payload.startswith("project_summary:"))
async def handle_project_summary_callback(event: MessageCallback):
    await handle_callback_project_summary(event)

@dp.message_callback(F.callback.payload.startswith("project_invite:"))
async def handle_project_invite_callback(event: MessageCallback):
    await handle_callback_project_invite(event)

@dp.message_callback(F.callback.payload.startswith("project_requests:"))
async def handle_project_requests_callback(event: MessageCallback):
    await handle_callback_project_requests(event)

@dp.message_callback(F.callback.payload.startswith("notifications"))
async def handle_notifications_callback(event: MessageCallback):
    await handle_callback_notifications(event)

@dp.message_callback(F.callback.payload.startswith("create_project_start"))
async def handle_create_start_callback(event: MessageCallback):
    await handle_callback_create_project_start(event)

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())

```

### app\config.py

```py```
# bot/app/config.py
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    BOT_TOKEN: str
    BACKEND_API_URL: str
    SITE_URL: str = "http://localhost:3000"  # –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É —Å—Ç—Ä–æ–∫—É

    class Config:
        env_file = ".env"

settings = Settings()

```

### app\utils.py

```py```
# bot/app/utils.py
import secrets
import string

def generate_invite_hash():
    return ''.join(secrets.choice(string.ascii_lowercase + string.digits) for _ in range(12))

```

### app\handlers\__init__.py

```py```
# bot/app/handlers/__init__.py
from .start import cmd_start
from .projects import (
    cmd_create_project, cmd_join_project,
    handle_callback_create_project_start,
    handle_callback_projects,
    handle_callback_project_summary,
    handle_callback_project_invite,
    handle_callback_project_requests
)
from .notifications import handle_callback_notifications

__all__ = [
    "cmd_start",
    "cmd_create_project",
    "cmd_join_project",
    "handle_callback_create_project_start",
    "handle_callback_projects",
    "handle_callback_project_summary",
    "handle_callback_project_invite",
    "handle_callback_project_requests",
    "handle_callback_notifications"
]

```

### app\handlers\notifications.py

```py```
# bot/app/handlers/notifications.py
from maxapi.types import MessageCallback, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from app.services.api_client import APIClient
from app.config import settings

api_client = APIClient()

async def handle_callback_notifications(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    data = await api_client.get_user_notifications(user_id)
    notifications = data.get("notifications", [])

    if not notifications:
        text = "üì≠ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.\n–ù–æ–≤—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å, –∫–æ–≥–¥–∞ –≤ –≤–∞—à–∏—Ö –ø—Ä–æ–µ–∫—Ç–∞—Ö —á—Ç–æ-—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç!"
    else:
        text = "üîî **–ü–æ—Å–ª–µ–¥–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:**\n"
        for i, notification in enumerate(notifications[:5], 1):
            emoji = "üîµ" if not notification.get("is_read") else "‚ö™"
            text += f"{emoji} **{notification.get('title', '')}**\n"
            text += f"{notification.get('message', '')}\n"
            text += "\n"

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={event.from_user.user_id}#notifications"
    builder.row(CallbackButton(text="üåê –û—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", payload="notifications"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

```

### app\handlers\projects.py

```py```
# bot/app/handlers/projects.py
from maxapi.types import MessageCreated, MessageCallback, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from maxapi.filters.command import Command
from app.services.api_client import APIClient
from app.utils import generate_invite_hash
from app.config import settings
import re

api_client = APIClient()

async def cmd_create_project(event: MessageCreated):
    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="üìÅ –ù–∞—á–∞—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ", payload="create_project_start"))
    await event.message.answer("–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞.", attachments=[builder.as_markup()])

async def handle_callback_create_project_start(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}#projects"
    await event.message.answer(f"–î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ: {web_app_url}")

async def cmd_join_project(event: MessageCreated):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "–ê–Ω–æ–Ω–∏–º"
    text = event.message.body.text.strip()

    parts = text.split(" ", 1)
    if len(parts) < 2:
        await event.message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Ö—ç—à –ø—Ä–æ–µ–∫—Ç–∞. –ü—Ä–∏–º–µ—Ä: /join abc123def456")
        return

    project_hash = parts[1]
    if len(project_hash) != 12 or not re.match(r'^[a-z0-9]+$', project_hash):
        await event.message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ö—ç—à–∞ –ø—Ä–æ–µ–∫—Ç–∞. –î–æ–ª–∂–Ω–æ –±—ã—Ç—å 12 —Å–∏–º–≤–æ–ª–æ–≤ (a-z, 0-9).")
        return

    result = await api_client.request_join_project(project_hash, user_id, full_name)
    if result.get("status") == "joined":
        await event.message.answer("‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –ø—Ä–æ–µ–∫—Ç—É!")
    elif result.get("message") == "Join request sent for approval":
        await event.message.answer("üì• –ó–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –æ–¥–æ–±—Ä–µ–Ω–∏–µ!")
    elif result.get("message") == "Already a member of this project":
        await event.message.answer("‚ùå –í—ã —É–∂–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —ç—Ç–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞.")
    else:
        await event.message.answer(f"‚ùå {result.get('message', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}")

async def handle_callback_projects(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "–ê–Ω–æ–Ω–∏–º"
    projects_data = await api_client.get_user_projects(user_id)

    if not projects_data:
        text = "üìÇ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–æ–≤!"
    else:
        text = "üìÇ **–í–∞—à–∏ –ø—Ä–æ–µ–∫—Ç—ã:**\n"
        for i, member in enumerate(projects_data[:5], 1):
            project = member.get("project", {})
            role_emoji = {"owner": "üëë", "admin": "‚ö°", "member": "üë§"}.get(member.get("role"), "üë§")
            tasks_count = len(project.get("tasks", []))
            text += f"{i}. {role_emoji} **{project.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}**\n"
            text += f"üìã {tasks_count} –∑–∞–¥–∞—á | üë• {len(project.get('members', []))} —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤\n"
            text += f"üîó –•—ç—à: `{project.get('hash', '')}`\n\n"

    builder = InlineKeyboardBuilder()
    for i, member in enumerate(projects_data[:5], 1):
        project = member.get("project", {})
        if member.get("role") in ["owner", "admin"]:
            builder.row(
                CallbackButton(text=f"üîç {i} - –ü–æ–¥—Ä–æ–±–Ω–µ–µ", payload=f"project_summary:{project.get('hash')}"),
                CallbackButton(text=f"üîó {i} - –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å", payload=f"project_invite:{project.get('hash')}")
            )

    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}"
    builder.row(CallbackButton(text="üåê –û—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_summary(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞")
        return

    project_hash = parts[1]
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "–ê–Ω–æ–Ω–∏–º"

    summary = await api_client.get_project_summary(project_hash, user_id, full_name)
    if not summary:
        await event.answer(notification="‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–µ–∫—Ç–µ")
        return

    text = (
        f"üöÄ **{summary['title']}**\n"
        f"{summary['description'] or 'üìù –ë–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è'}\n"
        f"üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**\n"
        f"‚Ä¢ üë• –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {summary['members_count']}\n"
        f"‚Ä¢ üìã –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {summary['tasks_count']}\n"
        f"‚Ä¢ ‚è≥ –ö –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—é: {summary['tasks_todo']}\n"
        f"‚Ä¢ üîß –í —Ä–∞–±–æ—Ç–µ: {summary['tasks_in_progress']}\n"
        f"‚Ä¢ ‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {summary['tasks_done']}\n"
        f"üîê {'üîí –ü—Ä–∏–≤–∞—Ç–Ω—ã–π' if summary['is_private'] else 'üåê –ü—É–±–ª–∏—á–Ω—ã–π'}\n"
        f"üìã {'‚úÖ –û–¥–æ–±—Ä–µ–Ω–∏–µ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è' if not summary['requires_approval'] else '‚è≥ –¢—Ä–µ–±—É–µ—Ç—Å—è –æ–¥–æ–±—Ä–µ–Ω–∏–µ'}\n"
        f"üë§ –í–∞—à–∞ —Ä–æ–ª—å: {summary['user_role']}"
    )

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}#project={project_hash}"
    builder.row(CallbackButton(text="üåê –û—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", payload=f"open_webapp:{web_app_url}"))

    if summary.get('can_manage'):
        builder.row(CallbackButton(text="üîó –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å", payload=f"project_invite:{project_hash}"))
        builder.row(CallbackButton(text="üìã –ó–∞—è–≤–∫–∏", payload=f"project_requests:{project_hash}"))

    builder.row(CallbackButton(text="üìã –ú–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_invite(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞")
        return

    project_hash = parts[1]
    invite_link = f"{settings.SITE_URL}/join/{project_hash}"
    text = f"üîó **–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –ø—Ä–æ–µ–∫—Ç**\n–ü—Ä–æ–µ–∫—Ç: **{project_hash}**\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ —ç—Ç—É —Å—Å—ã–ª–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º:\n`{invite_link}`\n–ò–ª–∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å —Ö—ç—à–µ–º –ø—Ä–æ–µ–∫—Ç–∞:\n`{project_hash}`"

    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="üìã –ú–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_requests(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞")
        return

    project_hash = parts[1]
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "–ê–Ω–æ–Ω–∏–º"

    data = await api_client.get_project_join_requests(project_hash, user_id, full_name)
    requests = data.get("requests", [])

    if not requests:
        text = "üìã **–ó–∞—è–≤–∫–∏ –Ω–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ**\n\n–ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –∑–∞—è–≤–æ–∫."
    else:
        text = "üìã **–ó–∞—è–≤–∫–∏ –Ω–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ**\n\n"
        for i, req in enumerate(requests, 1):
            user = req.get("user", {})
            text += f"{i}. {user.get('full_name', '–ê–Ω–æ–Ω–∏–º')} (ID: {user.get('max_id')})\n"
            text += f"–°—Ç–∞—Ç—É—Å: {req.get('status', 'pending')}\n"
            text += f"–î–∞—Ç–∞: {req.get('requested_at', 'N/A')}\n"
            text += f"---\n"

    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="üìã –ú–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

```

### app\handlers\start.py

```py```
# bot/app/handlers/start.py
from maxapi.types import MessageCreated, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from app.services.api_client import APIClient
from app.config import settings

api_client = APIClient()

async def cmd_start(event: MessageCreated):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "–ê–Ω–æ–Ω–∏–º"

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}"
    builder.row(CallbackButton(text="üåê –û—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="üìã –ú–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã", payload="projects"))
    builder.row(CallbackButton(text="üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", payload="notifications"))

    await event.message.answer(
        text=f"üëã –ü—Ä–∏–≤–µ—Ç, {full_name}!\n"
             f"üöÄ **MAX Project Pilot**\n"
             f"–£–ø—Ä–∞–≤–ª—è–π—Ç–µ –ø—Ä–æ–µ–∫—Ç–∞–º–∏ —á–µ—Ä–µ–∑ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏–ª–∏ –ø–æ–ª—É—á–∞–π—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∑–¥–µ—Å—å!\n"
             f"üí° **–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**\n"
             f"‚Ä¢ /create_project - –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç\n"
             f"‚Ä¢ /join <—Ö—ç—à> - –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ø—Ä–æ–µ–∫—Ç—É\n"
             f"‚Ä¢ /help - –ü–æ–º–æ—â—å",
        attachments=[builder.as_markup()]
    )

```

### app\services\__init__.py

```py```
# bot/app/services/__init__.py
# –≠—Ç–æ—Ç —Ñ–∞–π–ª –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –±–∞–∑–æ–≤—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ø–∞–∫–µ—Ç–∞ services
# –∏–ª–∏ –∏–º–ø–æ—Ä—Ç—ã –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
# from .api_client import APIClient

```

### app\services\api_client.py

```py```
# bot/app/services/api_client.py
import aiohttp
from app.config import settings
from loguru import logger
import json

class APIClient:
    def __init__(self):
        self.base_url = settings.BACKEND_API_URL

    async def get_user_projects(self, user_id: str):
        url = f"{self.base_url}/users/{user_id}/projects"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data.get("projects", [])
                    else:
                        logger.error(f"API Error: {response.status}")
                        return []
        except Exception as e:
            logger.error(f"Network error: {e}")
            return []

    async def create_project(self, user_id: str, full_name: str, title: str, description: str = ""):
        url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._create_project_with_token(title, description, access_token)
        except Exception as e:
            logger.error(f"Error getting token: {e}")
        return None

    async def _create_project_with_token(self, title: str, description: str, token: str):
        url = f"{self.base_url}/projects/"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        data = {"title": title, "description": description}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data, headers=headers) as response:
                    if response.status == 200:
                        project_data = await response.json()
                        return project_data.get("project")
        except Exception as e:
            logger.error(f"Error creating project: {e}")
        return None

    async def get_project_by_hash(self, project_hash: str):
        # –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, –µ—Å—Ç—å —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞ –ø–æ —Ö—ç—à—É –±–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        # –∏–ª–∏ —Å —Ç–æ–∫–µ–Ω–æ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞, —á—Ç–æ —Å–ª–æ–∂–Ω–æ –≤ –±–æ—Ç–µ. –†–µ–∞–ª–∏–∑—É–µ–º –∫–∞–∫ –≤—ã–∑–æ–≤ –∏–∑ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
        # –í –±–æ—Ç–µ –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ join.
        # –ò–ª–∏ –±–æ—Ç –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–∫–µ–Ω —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        # –î–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è, –ø—É—Å—Ç—å –±–æ—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–æ–∫–µ–Ω –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞.
        # –ü–æ–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª—É—à–∫—É.
        pass

    async def request_join_project(self, project_hash: str, user_id: str, full_name: str):
        # –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._request_join_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for join: {e}")
        return {"status": "error", "message": "Failed to get token"}

    async def _request_join_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
                    elif response.status == 404:
                        return {"status": "error", "message": "Project not found"}
                    elif response.status == 400:
                        error_json = await response.json()
                        return {"status": "error", "message": error_json.get("detail", "Already a member")}
        except Exception as e:
            logger.error(f"Error requesting join: {e}")
        return {"status": "error", "message": "Failed to join project"}

    async def get_user_notifications(self, user_id: str):
        # –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, –ø–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": "Anonymous"} # –ò–º—è –Ω–µ –≤–∞–∂–Ω–æ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_notifications_with_token(access_token)
        except Exception as e:
            logger.error(f"Error getting token for notifications: {e}")
        return {"notifications": []}

    async def get_project_summary(self, project_hash: str, user_id: str, full_name: str):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è –±–æ—Ç–∞"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_project_summary_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for project summary: {e}")
        return None

    async def _get_project_summary_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/summary"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error getting project summary: {e}")
        return None

    async def get_project_join_requests(self, project_hash: str, user_id: str, full_name: str):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –ø—Ä–æ–µ–∫—Ç—É"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_project_join_requests_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for join requests: {e}")
        return {"requests": []}

    async def _get_project_join_requests_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error getting join requests: {e}")
        return {"requests": []}

    async def approve_join_request(self, project_hash: str, request_id: int, user_id: str, full_name: str):
        """–û–¥–æ–±—Ä–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._approve_join_request_with_token(project_hash, request_id, access_token)
        except Exception as e:
            logger.error(f"Error getting token for approve: {e}")
        return {"status": "error", "message": "Failed to approve"}

    async def _approve_join_request_with_token(self, project_hash: str, request_id: int, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests/{request_id}/approve"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error approving join request: {e}")
        return {"status": "error", "message": "Failed to approve"}

    async def reject_join_request(self, project_hash: str, request_id: int, user_id: str, full_name: str):
        """–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._reject_join_request_with_token(project_hash, request_id, access_token)
        except Exception as e:
            logger.error(f"Error getting token for reject: {e}")
        return {"status": "error", "message": "Failed to reject"}

    async def _reject_join_request_with_token(self, project_hash: str, request_id: int, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests/{request_id}/reject"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error rejecting join request: {e}")
        return {"status": "error", "message": "Failed to reject"}

```

