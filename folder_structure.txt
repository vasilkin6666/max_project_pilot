# Структура папки: E:\GUAP\max_project_pilot

## Дерево каталогов

```
max_project_pilot/
  .env
  .env.example
  .gitignore
  README.md
  backend/
    Dockerfile
    alembic/
      env.py
      script.py.mako
      versions/
    alembic.ini
    app/
      __init__.py
      api/
        __init__.py
        auth.py
        deps.py
        notifications.py
        projects.py
        tasks.py
        users.py
      config.py
      core/
        exceptions.py
        security.py
      database.py
      main.py
      models/
        __init__.py
        base.py
        enums.py
        notification.py
        project.py
        task.py
        user.py
    requirements.txt
  bot/
    Dockerfile
    app/
      __init__.py
      bot.py
      config.py
      handlers/
        __init__.py
        notifications.py
        projects.py
        start.py
      services/
        __init__.py
        api_client.py
      utils.py
    folder_structure.txt
    requirements.txt
  docker-compose.yml
  web/
    README.md
    assets/
      favicon.ico
    css/
      style.css
    index.html
    js/
      api.js
      auth.js
      dashboard.js
      main.js
      projects.js
      tasks.js
```

## Содержимое файлов

### .env

```txt```
# .env
# --- Общие ---
APP_ENV=production

# --- Бот ---
BOT_TOKEN=f9LHodD0cOKTlb3nlkLwZ_zwBGlbLSE4nWjnbWoP6tvBs3HQbTMLAGyVR2aP8cfg37-NusW0KG_CdvMtxNN1A

# --- Backend ---
BACKEND_HOST=0.0.0.0
BACKEND_PORT=8000
POSTGRES_SERVER=db
POSTGRES_PORT=5432
POSTGRES_DB=max_pilot_db
POSTGRES_USER=max_user
POSTGRES_PASSWORD=your_secure_password

# --- Секретные ключи ---
SECRET_KEY=your-super-secret-key-for-jwt
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# --- URL-ы ---
SITE_URL=http://localhost:8000 # URL для GitHub Pages (пока локальный для теста)
BACKEND_API_URL=http://localhost:8000/api # URL API для бота (в проде: http://ваш_сервер:порт/api)

```

### .env.example

```example```
# .env.example
# --- Общие ---
APP_ENV=development

# --- Бот ---
BOT_TOKEN=your_max_bot_token

# --- Backend ---
BACKEND_HOST=0.0.0.0
BACKEND_PORT=8000
POSTGRES_SERVER=db
POSTGRES_PORT=5432
POSTGRES_DB=max_pilot_db
POSTGRES_USER=max_user
POSTGRES_PASSWORD=your_secure_password

# --- Секретные ключи ---
SECRET_KEY=your-super-secret-key-for-jwt
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# --- URL-ы ---
SITE_URL=https://your-github-username.github.io/your-repo-name # Пример для GitHub Pages
BACKEND_API_URL=http://your-server-ip:8000/api # Пример для вашего сервера

```

### .gitignore

```txt```
# .gitignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.venv
venv/
env/
.ENV

# Backend
backend/app/data/
backend/alembic/versions/*.py

# Bot

# Web
web/node_modules/
web/dist/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

```

### README.md

```md```
# MAX Project Pilot

Многофункциональная система управления проектами, интегрированная с мессенджером MAX. Включает бота, веб-приложение и API для управления задачами, проектами, участниками и уведомлениями.

## Особенности

- **Роли пользователей**: Владелец, Администратор, Участник, Гость.
- **Управление задачами**: Статусы (К выполнению, В работе, Завершено), приоритеты, исполнители.
- **Управление проектами**: Приватные/публичные, с одобрением участников.
- **Уведомления**: В боте и в веб-приложении.
- **Дополнительные функции**:
  - Таймер Pomodoro.
  - Зависимости задач.
  - Подзадачи (чек-листы).
  - Комментарии с упоминаниями.
  - Прикрепление файлов.
  - Авто-сохранение описания.
  - Поиск по задачам.
  - Эмодзи в названиях.
  - Drag & Drop задач.
  - Авто-обновление.
  - QR-коды для приглашений.
  - Темная тема.

## Архитектура

- **Backend**: FastAPI, PostgreSQL, SQLAlchemy, Alembic.
- **Bot**: Python, `maxapi` SDK.
- **Web**: Статический HTML/CSS/JS, размещается на GitHub Pages.
- **Docker**: Контейнеризация для всех компонентов.

## Установка и запуск

1. Скопируйте репозиторий.
2. Скопируйте `.env.example` в `.env` и заполните переменные.
3. Установите Docker и Docker Compose.
4. Выполните `docker-compose up -d`.

## Лицензия

MIT

```

### docker-compose.yml

```yml```
# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:15
    container_name: max_pilot_db
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      # Используем именованный том, определённый внизу
      - postgres_data:/var/lib/postgresql/data
      # Если нужно, можно также монтировать локальную директорию (не рекомендуется для production без контроля прав)
      # - ./init.sql:/docker-entrypoint-initdb.d/init.sql # Пример для инициализации
    ports:
      # Открываем порт 5432 только для отладки. В продакшене НЕ открывать!
      # Убедитесь, что он не конфликтует с локальным PostgreSQL.
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    container_name: max_pilot_backend
    ports:
      - "${BACKEND_PORT}:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:${POSTGRES_PORT}/${POSTGRES_DB} # Используем имя сервиса 'db'
      - SECRET_KEY=${SECRET_KEY}
      - ALGORITHM=${ALGORITHM}
      - ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
      - SITE_URL=${SITE_URL}
      - BACKEND_API_URL=${BACKEND_API_URL} # Убедитесь, что это публичный URL для бота
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped
    # Важно: backend не должен зависеть от bot
    # depends_on не ждёт готовности bot, только запуска.

  bot:
    build: ./bot
    container_name: max_pilot_bot
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      # В Docker Compose внутренний URL для backend - это имя сервиса
      - BACKEND_API_URL=http://backend:8000/api
      # Для внешнего мира (например, если bot логирует URL для отладки)
      # используйте переменную из .env, но для внутреннего взаимодействия - имя сервиса.
    depends_on:
      - backend
    restart: unless-stopped
    # Убедитесь, что bot не пытается использовать порт, конфликтующий с чем-то другим.
    # Long Polling не требует открытия портов для входящих соединений от MAX API.

# Определение томов
volumes:
  postgres_data: # Именованный том для данных PostgreSQL
    # driver: local # Необязательно, по умолчанию local
    # driver_opts: # Необязательно, можно указать опции драйвера
    #   type: none
    #   o: bind
    #   device: /host/path/directory # Только для типа 'bind'

```

### backend\Dockerfile

```txt```
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

```

### backend\alembic.ini

```ini```
# backend/alembic.ini
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# max_length = 40

# version number display, one of:
# "short" - short version number (e.g. "1a2b3c4")
# "long" - full version number with all digits (e.g. "1234567890abcdef")
# "none" - no version number in the filename
version_num_in_file = false

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses
# os.pathsep. If this key is omitted entirely, it falls back to the legacy
# behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

```

### backend\requirements.txt

```txt```
fastapi==0.115.0
uvicorn[standard]==0.30.6
sqlalchemy[asyncio]==2.0.35
asyncpg==0.29.0
alembic==1.13.1
pydantic==2.9.2
pydantic-settings==2.5.2
python-dotenv==1.0.1
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.17
loguru==0.7.2

```

### backend\alembic\env.py

```py```
# backend/alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context
from app.models import Base  # Импортируем Base из вашей модели
from app.config import settings # Импортируем настройки

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = settings.DATABASE_URL # Используем URL из настроек
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    configuration = config.get_section(config.config_ini_section)
    configuration['sqlalchemy.url'] = settings.DATABASE_URL # Подставляем URL из настроек
    connectable = engine_from_config(
        configuration,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

### backend\alembic\script.py.mako

```mako```
# backend/alembic/script.py.mako
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}

```

### backend\app\__init__.py

```py```
# backend/app/__init__.py
# Этот файл может быть пустым или содержать базовую инициализацию пакета app

```

### backend\app\config.py

```py```
# backend/app/config.py
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    DATABASE_URL: str
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    SITE_URL: str
    BACKEND_API_URL: str # Добавлено для бота

    class Config:
        env_file = ".env"

settings = Settings()

```

### backend\app\database.py

```py```
# backend/app/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from .config import settings

DATABASE_URL = settings.DATABASE_URL

engine = create_async_engine(DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session

```

### backend\app\main.py

```py```
# backend/app/main.py
from fastapi import FastAPI
from app.api.auth import router as auth_router
from app.api.users import router as users_router
from app.api.projects import router as projects_router
from app.api.tasks import router as tasks_router
from app.api.notifications import router as notifications_router
from app.models import Base
from app.database import engine
from sqlalchemy import select

app = FastAPI(title="MAX Project Pilot API", version="1.0.0")

# Инициализация БД (в реальности используйте Alembic)
@app.on_event("startup")
async def startup():
    async with engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all) # Не удалять в проде!
        await conn.run_sync(Base.metadata.create_all)

# Health check
@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "MAX Project Pilot Backend", "version": "1.0.0"}

app.include_router(auth_router)
app.include_router(users_router)
app.include_router(projects_router)
app.include_router(tasks_router)
app.include_router(notifications_router)

```

### backend\app\api\__init__.py

```py```
# backend/app/api/__init__.py
# Этот файл может быть пустым или содержать импорты для удобства
# from . import auth, projects, tasks, users, notifications

```

### backend\app\api\auth.py

```py```
# backend/app/api/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.database import get_db
from app.models import User
from app.core.security import create_access_token
from datetime import timedelta
from app.config import settings

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/token")
async def login_or_create_user(max_id: str, full_name: str, username: str = None, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User).where(User.max_id == max_id))
    user = result.scalar_one_or_none()
    if not user:
        user = User(max_id=max_id, full_name=full_name, username=username)
        db.add(user)
        await db.commit()
        await db.refresh(user)

    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.max_id}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer", "user": {"id": user.max_id, "full_name": user.full_name}}

```

### backend\app\api\deps.py

```py```
# backend/app/api/deps.py
from fastapi import Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db
from app.models import User
from app.core.security import verify_token
from sqlalchemy import select

async def get_current_user(token: str, db: AsyncSession = Depends(get_db)):
    user_id = verify_token(token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    result = await db.execute(select(User).where(User.max_id == user_id))
    user = result.scalar_one_or_none()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user

```

### backend\app\api\notifications.py

```py```
# backend/app/api/notifications.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from app.database import get_db
from app.models import User, Notification
from app.api.deps import get_current_user

router = APIRouter(prefix="/notifications", tags=["notifications"])

@router.get("/")
async def get_user_notifications(
    user_id: str, # Для совместимости с MAX Web App
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(
        select(Notification)
        .where(Notification.user_id == current_user.id)
        .order_by(Notification.created_at.desc())
    )
    notifications = result.scalars().all()
    return {"notifications": notifications}

@router.put("/mark_all_read")
async def mark_all_notifications_read(
    user_id: str, # Для совместимости с MAX Web App
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    stmt = update(Notification).where(
        Notification.user_id == current_user.id,
        Notification.is_read == False
    ).values(is_read=True)
    await db.execute(stmt)
    await db.commit()
    return {"status": "success", "message": "All notifications marked as read"}

```

### backend\app\api\projects.py

```py```
# backend/app/api/projects.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_
from app.database import get_db
from app.models import User, Project, ProjectMember, JoinRequest, Task
from app.api.deps import get_current_user
from app.models.enums import ProjectRole
import secrets
import string

router = APIRouter(prefix="/projects", tags=["projects"])

def generate_invite_hash():
    return ''.join(secrets.choice(string.ascii_lowercase + string.digits) for _ in range(12))

@router.post("/")
async def create_project(
    title: str,
    description: str = "",
    is_private: bool = True,
    requires_approval: bool = False,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    invite_hash = generate_invite_hash()
    project = Project(
        title=title,
        description=description,
        hash=invite_hash,
        is_private=is_private,
        requires_approval=requires_approval,
        created_by=current_user.id
    )
    db.add(project)
    await db.commit()
    await db.refresh(project)

    # Сделать создателя владельцем
    member = ProjectMember(
        project_id=project.id,
        user_id=current_user.id,
        role=ProjectRole.OWNER
    )
    db.add(member)
    await db.commit()

    return {"project": project}

@router.get("/{project_hash}")
async def get_project(project_hash: str, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Проверка доступа: владелец, админ, участник или публичный
    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project.id,
            ProjectMember.user_id == current_user.id
        )
    )
    member = membership.scalar_one_or_none()

    if project.is_private and not member:
        raise HTTPException(status_code=403, detail="Access denied")

    # Подсчет статистики
    stats_result = await db.execute(
        select(
            func.count(Task.id).label('total_tasks'),
            func.sum(func.iif(Task.status == 'done', 1, 0)).label('done_tasks'),
            func.sum(func.iif(Task.status == 'in_progress', 1, 0)).label('in_progress_tasks'),
            func.sum(func.iif(Task.status == 'todo', 1, 0)).label('todo_tasks')
        ).where(Task.project_id == project.id)
    )
    stats = stats_result.first()

    return {
        "project": project,
        "members": project.members,
        "stats": {
            "tasks_count": stats.total_tasks or 0,
            "tasks_done": stats.done_tasks or 0,
            "tasks_in_progress": stats.in_progress_tasks or 0,
            "tasks_todo": stats.todo_tasks or 0
        }
    }

@router.post("/{project_hash}/join")
async def join_project_request(project_hash: str, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Проверка, является ли пользователь уже участником
    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project.id,
            ProjectMember.user_id == current_user.id
        )
    )
    existing_member = membership.scalar_one_or_none()
    if existing_member:
        raise HTTPException(status_code=400, detail="Already a member of this project")

    if not project.requires_approval:
        # Прямое добавление
        member = ProjectMember(project_id=project.id, user_id=current_user.id, role=ProjectRole.MEMBER)
        db.add(member)
        await db.commit()
        return {"status": "joined", "message": "Successfully joined project"}
    else:
        # Проверка, нет ли уже запроса
        existing_request = await db.execute(
            select(JoinRequest).where(
                JoinRequest.project_id == project.id,
                JoinRequest.user_id == current_user.id,
                JoinRequest.status == "pending"
            )
        )
        if existing_request.scalar_one_or_none():
             raise HTTPException(status_code=400, detail="Join request already pending")

        # Создание запроса на присоединение
        join_request = JoinRequest(project_id=project.id, user_id=current_user.id)
        db.add(join_request)
        await db.commit()
        return {"status": "pending_approval", "message": "Join request sent for approval"}

@router.get("/{project_hash}/join-requests")
async def get_join_requests(project_hash: str, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project.id,
            ProjectMember.user_id == current_user.id
        )
    )
    member = membership.scalar_one_or_none()
    if not member or member.role not in [ProjectRole.OWNER, ProjectRole.ADMIN]:
        raise HTTPException(status_code=403, detail="Access denied")

    result = await db.execute(
        select(JoinRequest)
        .where(JoinRequest.project_id == project.id)
        .options(selectinload(JoinRequest.user))
    )
    requests = result.scalars().all()
    return {"requests": requests}

@router.post("/{project_hash}/join-requests/{request_id}/approve")
async def approve_join_request(project_hash: str, request_id: int, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project.id,
            ProjectMember.user_id == current_user.id
        )
    )
    member = membership.scalar_one_or_none()
    if not member or member.role not in [ProjectRole.OWNER, ProjectRole.ADMIN]:
        raise HTTPException(status_code=403, detail="Access denied")

    result = await db.execute(
        select(JoinRequest).where(
            JoinRequest.id == request_id,
            JoinRequest.project_id == project.id,
            JoinRequest.status == "pending"
        )
    )
    join_request = result.scalar_one_or_none()
    if not join_request:
        raise HTTPException(status_code=404, detail="Join request not found")

    # Добавить пользователя как участника
    new_member = ProjectMember(project_id=project.id, user_id=join_request.user_id, role=ProjectRole.MEMBER)
    db.add(new_member)

    # Обновить статус запроса
    join_request.status = "approved"
    join_request.processed_by_id = current_user.id
    join_request.processed_at = func.now()

    await db.commit()
    return {"status": "success", "message": "Join request approved"}

@router.post("/{project_hash}/join-requests/{request_id}/reject")
async def reject_join_request(project_hash: str, request_id: int, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project.id,
            ProjectMember.user_id == current_user.id
        )
    )
    member = membership.scalar_one_or_none()
    if not member or member.role not in [ProjectRole.OWNER, ProjectRole.ADMIN]:
        raise HTTPException(status_code=403, detail="Access denied")

    result = await db.execute(
        select(JoinRequest).where(
            JoinRequest.id == request_id,
            JoinRequest.project_id == project.id,
            JoinRequest.status == "pending"
        )
    )
    join_request = result.scalar_one_or_none()
    if not join_request:
        raise HTTPException(status_code=404, detail="Join request not found")

    # Обновить статус запроса
    join_request.status = "rejected"
    join_request.processed_by_id = current_user.id
    join_request.processed_at = func.now()

    await db.commit()
    return {"status": "success", "message": "Join request rejected"}

@router.post("/{project_hash}/regenerate-invite")
async def regenerate_invite(project_hash: str, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project.id,
            ProjectMember.user_id == current_user.id
        )
    )
    member = membership.scalar_one_or_none()
    if not member or member.role not in [ProjectRole.OWNER, ProjectRole.ADMIN]:
        raise HTTPException(status_code=403, detail="Access denied")

    new_hash = generate_invite_hash()
    project.hash = new_hash
    await db.commit()
    return {"status": "success", "new_invite_hash": new_hash}

@router.get("/{project_hash}/summary")
async def get_project_summary(project_hash: str, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    """Эндпоинт для получения сводки проекта для бота"""
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project.id,
            ProjectMember.user_id == current_user.id
        )
    )
    member = membership.scalar_one_or_none()
    if not member:
        raise HTTPException(status_code=403, detail="Access denied")

    # Подсчет статистики
    stats_result = await db.execute(
        select(
            func.count(Task.id).label('total_tasks'),
            func.sum(func.iif(Task.status == 'done', 1, 0)).label('done_tasks'),
            func.sum(func.iif(Task.status == 'in_progress', 1, 0)).label('in_progress_tasks'),
            func.sum(func.iif(Task.status == 'todo', 1, 0)).label('todo_tasks')
        ).where(Task.project_id == project.id)
    )
    stats = stats_result.first()

    return {
        "id": project.id,
        "title": project.title,
        "description": project.description,
        "hash": project.hash,
        "is_private": project.is_private,
        "requires_approval": project.requires_approval,
        "members_count": len(project.members),
        "tasks_count": stats.total_tasks or 0,
        "tasks_todo": stats.todo_tasks or 0,
        "tasks_in_progress": stats.in_progress_tasks or 0,
        "tasks_done": stats.done_tasks or 0,
        "user_role": member.role,
        "can_manage": member.role in [ProjectRole.OWNER, ProjectRole.ADMIN]
    }

```

### backend\app\api\tasks.py

```py```
# backend/app/api/tasks.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.database import get_db
from app.models import User, Project, ProjectMember, Task, TaskAssignee, Comment
from app.api.deps import get_current_user
from app.models.enums import ProjectRole, TaskStatus, TaskPriority

router = APIRouter(prefix="/tasks", tags=["tasks"])

async def check_project_access(project_id: int, user_id: int, db: AsyncSession) -> bool:
    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project_id,
            ProjectMember.user_id == user_id
        )
    )
    member = membership.scalar_one_or_none()
    return member is not None

async def check_project_manage_access(project_id: int, user_id: int, db: AsyncSession) -> bool:
    membership = await db.execute(
        select(ProjectMember).where(
            ProjectMember.project_id == project_id,
            ProjectMember.user_id == user_id
        )
    )
    member = membership.scalar_one_or_none()
    return member is not None and member.role in [ProjectRole.OWNER, ProjectRole.ADMIN]

@router.get("/")
async def get_tasks(
    user_id: str, # Для совместимости с MAX Web App
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    # Получить задачи, где пользователь является участником проекта или исполнителем
    result = await db.execute(
        select(Task)
        .join(Project)
        .join(ProjectMember, Project.id == ProjectMember.project_id)
        .where(ProjectMember.user_id == current_user.id)
        .order_by(Task.created_at.desc())
    )
    tasks = result.scalars().all()
    return {"tasks": tasks}

@router.get("/project/{project_hash}")
async def get_project_tasks(
    project_hash: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    has_access = await check_project_access(project.id, current_user.id, db)
    if not has_access:
        raise HTTPException(status_code=403, detail="Access denied")

    result = await db.execute(
        select(Task)
        .where(Task.project_id == project.id)
        .order_by(Task.created_at.desc())
    )
    tasks = result.scalars().all()
    return {"tasks": tasks}

@router.post("/")
async def create_task(
    title: str,
    project_hash: str,
    description: str = "",
    status: TaskStatus = TaskStatus.TODO,
    priority: TaskPriority = TaskPriority.MEDIUM,
    assigned_to_ids: list[int] = [], # IDs пользователей
    due_date: str = None, # ISO format string
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Project).where(Project.hash == project_hash))
    project = result.scalar_one_or_none()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    has_access = await check_project_access(project.id, current_user.id, db)
    if not has_access:
        raise HTTPException(status_code=403, detail="Access denied")

    task = Task(
        title=title,
        description=description,
        status=status,
        priority=priority,
        project_id=project.id,
        created_by=current_user.id
    )
    if due_date:
        from datetime import datetime
        task.due_date = datetime.fromisoformat(due_date.replace('Z', '+00:00'))
    db.add(task)
    await db.commit()
    await db.refresh(task)

    # Назначить исполнителей
    for user_id in assigned_to_ids:
        assignee = TaskAssignee(task_id=task.id, user_id=user_id)
        db.add(assignee)
    await db.commit()

    return {"task": task}

@router.put("/{task_id}/status")
async def update_task_status(
    task_id: int,
    status: TaskStatus,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Task).where(Task.id == task_id))
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    has_access = await check_project_access(task.project_id, current_user.id, db)
    if not has_access:
        raise HTTPException(status_code=403, detail="Access denied")

    # Проверка зависимостей (упрощенно)
    if status == TaskStatus.DONE and task.depends_on_id:
        dependency = await db.get(Task, task.depends_on_id)
        if dependency and dependency.status != TaskStatus.DONE:
            raise HTTPException(status_code=400, detail=f"Cannot complete task. Dependency '{dependency.title}' is not done.")

    task.status = status
    await db.commit()
    await db.refresh(task)

    # Уведомление (реализация опциональна, см. в уведомлениях)
    # await notify_task_status_changed(task.id, status)

    return {"task": task}

@router.get("/{task_id}/comments")
async def get_task_comments(
    task_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Task).where(Task.id == task_id))
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    has_access = await check_project_access(task.project_id, current_user.id, db)
    if not has_access:
        raise HTTPException(status_code=403, detail="Access denied")

    result = await db.execute(
        select(Comment)
        .where(Comment.task_id == task_id)
        .order_by(Comment.created_at.asc())
    )
    comments = result.scalars().all()
    return {"comments": comments}

@router.post("/{task_id}/comments")
async def create_task_comment(
    task_id: int,
    content: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Task).where(Task.id == task_id))
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    has_access = await check_project_access(task.project_id, current_user.id, db)
    if not has_access:
        raise HTTPException(status_code=403, detail="Access denied")

    comment = Comment(task_id=task_id, user_id=current_user.id, content=content)
    db.add(comment)
    await db.commit()
    await db.refresh(comment)

    return {"comment": comment}

@router.delete("/{task_id}")
async def delete_task(
    task_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Task).where(Task.id == task_id))
    task = result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    has_manage_access = await check_project_manage_access(task.project_id, current_user.id, db)
    if not has_manage_access:
        # Проверим, является ли пользователь создателем задачи
        if task.created_by != current_user.id:
            raise HTTPException(status_code=403, detail="Access denied")

    # Удаляем связанные назначения
    await db.execute(TaskAssignee.__table__.delete().where(TaskAssignee.task_id == task.id))
    # Удаляем задачу
    await db.delete(task)
    await db.commit()
    return {"status": "success", "message": "Task deleted"}

```

### backend\app\api\users.py

```py```
# backend/app/api/users.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.database import get_db
from app.models import User, ProjectMember
from app.api.deps import get_current_user

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user

@router.get("/{user_id}/projects")
async def get_user_projects(user_id: str, current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    if current_user.max_id != user_id:
        raise HTTPException(status_code=403, detail="Not authorized to view this user's projects")
    result = await db.execute(
        select(ProjectMember).where(ProjectMember.user_id == current_user.id)
    )
    memberships = result.scalars().all()
    projects = [member.project for member in memberships]
    return {"projects": projects}

```

### backend\app\core\exceptions.py

```py```
# backend/app/core/exceptions.py
from fastapi import HTTPException, status

class UnauthorizedException(HTTPException):
    def __init__(self, detail="Could not validate credentials"):
        super().__init__(status_code=status.HTTP_401_UNAUTHORIZED, detail=detail)

class ForbiddenException(HTTPException):
    def __init__(self, detail="Access denied"):
        super().__init__(status_code=status.HTTP_403_FORBIDDEN, detail=detail)

class NotFoundException(HTTPException):
    def __init__(self, detail="Item not found"):
        super().__init__(status_code=status.HTTP_404_NOT_FOUND, detail=detail)

class BadRequestException(HTTPException):
    def __init__(self, detail="Bad request"):
        super().__init__(status_code=status.HTTP_400_BAD_REQUEST, detail=detail)

```

### backend\app\core\security.py

```py```
# backend/app/core/security.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from ..config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token( dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            return None
        return user_id
    except JWTError:
        return None

```

### backend\app\models\__init__.py

```py```
# backend/app/models/__init__.py
from .base import Base
from .user import User
from .project import Project, ProjectMember, JoinRequest
from .task import Task, TaskAssignee, Comment
from .notification import Notification
from .enums import ProjectRole, TaskStatus, TaskPriority, NotificationType

```

### backend\app\models\base.py

```py```
# backend/app/models/base.py
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass

```

### backend\app\models\enums.py

```py```
# backend/app/models/enums.py
from enum import Enum

class ProjectRole(str, Enum):
    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    GUEST = "guest"

class TaskStatus(str, Enum):
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    DONE = "done"

class TaskPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class NotificationType(str, Enum):
    TASK_CREATED = "task_created"
    TASK_ASSIGNED = "task_assigned"
    TASK_STATUS_CHANGED = "task_status_changed"
    TASK_COMPLETED = "task_completed"
    JOIN_REQUEST = "join_request"
    JOIN_APPROVED = "join_approved"
    JOIN_REJECTED = "join_rejected"
    PROJECT_INVITE = "project_invite"

```

### backend\app\models\notification.py

```py```
# backend/app/models/notification.py
from sqlalchemy import Column, Integer, String, Text, Boolean, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base
from .enums import NotificationType

class Notification(Base):
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    project_id = Column(Integer, ForeignKey("projects.id"), nullable=True) # Опционально
    type = Column(String, nullable=False) # Хранение строки
    title = Column(String, nullable=False)
    message = Column(Text, nullable=False)
    data = Column(Text, nullable=True) # JSON-строка
    is_read = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    user = relationship("User", back_populates="notifications")
    project = relationship("Project")

```

### backend\app\models\project.py

```py```
# backend/app/models/project.py
from sqlalchemy import Column, Integer, String, Text, Boolean, ForeignKey, DateTime, UniqueConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base
from .enums import ProjectRole

class Project(Base):
    __tablename__ = "projects"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    hash = Column(String, unique=True, index=True, nullable=False) # Уникальный хэш для приглашений
    is_private = Column(Boolean, default=True)
    requires_approval = Column(Boolean, default=False)
    created_by = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    owner = relationship("User", back_populates="owned_projects")
    members = relationship("ProjectMember", back_populates="project", cascade="all, delete-orphan")
    tasks = relationship("Task", back_populates="project", cascade="all, delete-orphan")
    join_requests = relationship("JoinRequest", back_populates="project", cascade="all, delete-orphan")

class ProjectMember(Base):
    __tablename__ = "project_members"

    id = Column(Integer, primary_key=True, index=True)
    project_id = Column(Integer, ForeignKey("projects.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    role = Column(String, default=ProjectRole.MEMBER) # Хранение строки, не Enum
    joined_at = Column(DateTime(timezone=True), server_default=func.now())

    project = relationship("Project", back_populates="members")
    user = relationship("User", back_populates="projects")

    __table_args__ = (UniqueConstraint('project_id', 'user_id', name='unique_project_user'),)

class JoinRequest(Base):
    __tablename__ = "join_requests"

    id = Column(Integer, primary_key=True, index=True)
    project_id = Column(Integer, ForeignKey("projects.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False) # Кто подал запрос
    status = Column(String, default="pending") # pending, approved, rejected
    requested_at = Column(DateTime(timezone=True), server_default=func.now())
    processed_by_id = Column(Integer, ForeignKey("users.id"), nullable=True) # Кто обработал
    processed_at = Column(DateTime(timezone=True), nullable=True)

    project = relationship("Project", back_populates="join_requests")
    user = relationship("User", back_populates="join_requests")
    processor = relationship("User", foreign_keys=[processed_by_id], back_populates="processed_join_requests")

```

### backend\app\models\task.py

```py```
# backend/app/models/task.py
from sqlalchemy import Column, Integer, String, Text, Boolean, ForeignKey, DateTime, UniqueConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base
from .enums import TaskStatus, TaskPriority

class Task(Base):
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    status = Column(String, default=TaskStatus.TODO) # Хранение строки
    priority = Column(String, default=TaskPriority.MEDIUM) # Хранение строки
    project_id = Column(Integer, ForeignKey("projects.id"), nullable=False)
    created_by = Column(Integer, ForeignKey("users.id"), nullable=False)
    assigned_to_id = Column(Integer, ForeignKey("users.id"), nullable=True) # ID исполнителя
    due_date = Column(DateTime(timezone=True), nullable=True)
    parent_task_id = Column(Integer, ForeignKey("tasks.id"), nullable=True) # Для подзадач
    depends_on_id = Column(Integer, ForeignKey("tasks.id"), nullable=True) # Для зависимостей
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    project = relationship("Project", back_populates="tasks")
    creator = relationship("User", foreign_keys=[created_by])
    assignee = relationship("User", foreign_keys=[assigned_to_id])
    parent_task = relationship("Task", remote_side=[id], back_populates="subtasks")
    subtasks = relationship("Task", back_populates="parent_task", cascade="all, delete-orphan")
    dependencies = relationship("Task", remote_side=[id], back_populates="dependents")
    dependents = relationship("Task", back_populates="dependencies")
    assignees = relationship("TaskAssignee", back_populates="task", cascade="all, delete-orphan")
    comments = relationship("Comment", back_populates="task", cascade="all, delete-orphan")

class TaskAssignee(Base):
    __tablename__ = "task_assignees"

    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(Integer, ForeignKey("tasks.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    task = relationship("Task", back_populates="assignees")
    user = relationship("User")

    __table_args__ = (UniqueConstraint('task_id', 'user_id', name='unique_task_assignee'),)

class Comment(Base):
    __tablename__ = "comments"

    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(Integer, ForeignKey("tasks.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    task = relationship("Task", back_populates="comments")
    user = relationship("User")

```

### backend\app\models\user.py

```py```
# backend/app/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.sql import func
from .base import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    max_id = Column(String, unique=True, index=True, nullable=False) # ID из MAX
    full_name = Column(String, nullable=False)
    username = Column(String, nullable=True) # MAX username
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

```

### bot\Dockerfile

```txt```
# bot/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "-m", "app.bot"]

```

### bot\folder_structure.txt

```txt```
# Структура папки: E:\GUAP\max_project_pilot\bot

## Дерево каталогов

```
bot/
  Dockerfile
  app/
    __init__.py
    bot.py
    config.py
    handlers/
      __init__.py
      notifications.py
      projects.py
      start.py
    services/
      __init__.py
      api_client.py
    utils.py
  requirements.txt
```

## Содержимое файлов

### Dockerfile

```txt```
# bot/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "-m", "app.bot"]

```

### requirements.txt

```txt```
maxapi==0.9.7
requests==2.32.3
python-dotenv==1.0.1
loguru==0.7.2
aiohttp>=3.12.14
pydantic-settings>=2.0.0
pydantic>=2.0.0

```

### app\__init__.py

```py```
# bot/app/__init__.py
# Этот файл может быть пустым или содержать базовую инициализацию пакета app

```

### app\bot.py

```py```
# bot/app/bot.py
import asyncio
from maxapi import Bot, Dispatcher, F
from maxapi.types import MessageCreated, MessageCallback
from maxapi.filters.command import Command

from app.config import settings
from app.handlers import (
    cmd_start, cmd_create_project, cmd_join_project,
    handle_callback_create_project_start,
    handle_callback_projects,
    handle_callback_project_summary,
    handle_callback_project_invite,
    handle_callback_project_requests,
    handle_callback_notifications
)

bot = Bot(token=settings.BOT_TOKEN)
dp = Dispatcher()

@dp.message_created(Command('start'))
async def handle_start(event: MessageCreated):
    await cmd_start(event)

@dp.message_created(Command('create_project'))
async def handle_create_project(event: MessageCreated):
    await cmd_create_project(event)

@dp.message_created(Command('join'))
async def handle_join_project(event: MessageCreated):
    await cmd_join_project(event)

@dp.message_callback(F.callback.payload.startswith("projects"))
async def handle_projects_callback(event: MessageCallback):
    await handle_callback_projects(event)

@dp.message_callback(F.callback.payload.startswith("project_summary:"))
async def handle_project_summary_callback(event: MessageCallback):
    await handle_callback_project_summary(event)

@dp.message_callback(F.callback.payload.startswith("project_invite:"))
async def handle_project_invite_callback(event: MessageCallback):
    await handle_callback_project_invite(event)

@dp.message_callback(F.callback.payload.startswith("project_requests:"))
async def handle_project_requests_callback(event: MessageCallback):
    await handle_callback_project_requests(event)

@dp.message_callback(F.callback.payload.startswith("notifications"))
async def handle_notifications_callback(event: MessageCallback):
    await handle_callback_notifications(event)

@dp.message_callback(F.callback.payload.startswith("create_project_start"))
async def handle_create_start_callback(event: MessageCallback):
    await handle_callback_create_project_start(event)

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())

```

### app\config.py

```py```
# bot/app/config.py
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    BOT_TOKEN: str
    BACKEND_API_URL: str
    SITE_URL: str = "http://localhost:3000"  # Добавьте эту строку

    class Config:
        env_file = ".env"

settings = Settings()

```

### app\utils.py

```py```
# bot/app/utils.py
import secrets
import string

def generate_invite_hash():
    return ''.join(secrets.choice(string.ascii_lowercase + string.digits) for _ in range(12))

```

### app\handlers\__init__.py

```py```
# bot/app/handlers/__init__.py
from .start import cmd_start
from .projects import (
    cmd_create_project, cmd_join_project,
    handle_callback_create_project_start,
    handle_callback_projects,
    handle_callback_project_summary,
    handle_callback_project_invite,
    handle_callback_project_requests
)
from .notifications import handle_callback_notifications

__all__ = [
    "cmd_start",
    "cmd_create_project",
    "cmd_join_project",
    "handle_callback_create_project_start",
    "handle_callback_projects",
    "handle_callback_project_summary",
    "handle_callback_project_invite",
    "handle_callback_project_requests",
    "handle_callback_notifications"
]

```

### app\handlers\notifications.py

```py```
# bot/app/handlers/notifications.py
from maxapi.types import MessageCallback, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from app.services.api_client import APIClient
from app.config import settings

api_client = APIClient()

async def handle_callback_notifications(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    data = await api_client.get_user_notifications(user_id)
    notifications = data.get("notifications", [])

    if not notifications:
        text = "📭 У вас пока нет уведомлений.\nНовые уведомления появятся здесь, когда в ваших проектах что-то произойдет!"
    else:
        text = "🔔 **Последние уведомления:**\n"
        for i, notification in enumerate(notifications[:5], 1):
            emoji = "🔵" if not notification.get("is_read") else "⚪"
            text += f"{emoji} **{notification.get('title', '')}**\n"
            text += f"{notification.get('message', '')}\n"
            text += "\n"

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={event.from_user.user_id}#notifications"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="🔄 Обновить", payload="notifications"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

```

### app\handlers\projects.py

```py```
# bot/app/handlers/projects.py
from maxapi.types import MessageCreated, MessageCallback, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from maxapi.filters.command import Command
from app.services.api_client import APIClient
from app.utils import generate_invite_hash
from app.config import settings
import re

api_client = APIClient()

async def cmd_create_project(event: MessageCreated):
    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="📁 Начать создание", payload="create_project_start"))
    await event.message.answer("Нажмите кнопку, чтобы начать создание проекта.", attachments=[builder.as_markup()])

async def handle_callback_create_project_start(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}#projects"
    await event.message.answer(f"Для создания проекта перейдите в веб-приложение: {web_app_url}")

async def cmd_join_project(event: MessageCreated):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"
    text = event.message.body.text.strip()

    parts = text.split(" ", 1)
    if len(parts) < 2:
        await event.message.answer("Пожалуйста, укажите хэш проекта. Пример: /join abc123def456")
        return

    project_hash = parts[1]
    if len(project_hash) != 12 or not re.match(r'^[a-z0-9]+$', project_hash):
        await event.message.answer("Неверный формат хэша проекта. Должно быть 12 символов (a-z, 0-9).")
        return

    result = await api_client.request_join_project(project_hash, user_id, full_name)
    if result.get("status") == "joined":
        await event.message.answer("✅ Вы успешно присоединились к проекту!")
    elif result.get("message") == "Join request sent for approval":
        await event.message.answer("📥 Запрос на присоединение отправлен на одобрение!")
    elif result.get("message") == "Already a member of this project":
        await event.message.answer("❌ Вы уже являетесь участником этого проекта.")
    else:
        await event.message.answer(f"❌ {result.get('message', 'Неизвестная ошибка')}")

async def handle_callback_projects(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"
    projects_data = await api_client.get_user_projects(user_id)

    if not projects_data:
        text = "📂 У вас пока нет проектов. Используйте веб-приложение для создания проектов!"
    else:
        text = "📂 **Ваши проекты:**\n"
        for i, member in enumerate(projects_data[:5], 1):
            project = member.get("project", {})
            role_emoji = {"owner": "👑", "admin": "⚡", "member": "👤"}.get(member.get("role"), "👤")
            tasks_count = len(project.get("tasks", []))
            text += f"{i}. {role_emoji} **{project.get('title', 'Без названия')}**\n"
            text += f"📋 {tasks_count} задач | 👥 {len(project.get('members', []))} участников\n"
            text += f"🔗 Хэш: `{project.get('hash', '')}`\n\n"

    builder = InlineKeyboardBuilder()
    for i, member in enumerate(projects_data[:5], 1):
        project = member.get("project", {})
        if member.get("role") in ["owner", "admin"]:
            builder.row(
                CallbackButton(text=f"🔍 {i} - Подробнее", payload=f"project_summary:{project.get('hash')}"),
                CallbackButton(text=f"🔗 {i} - Пригласить", payload=f"project_invite:{project.get('hash')}")
            )

    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="🔄 Обновить", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_summary(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="❌ Неверная команда")
        return

    project_hash = parts[1]
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"

    summary = await api_client.get_project_summary(project_hash, user_id, full_name)
    if not summary:
        await event.answer(notification="❌ Не удалось получить информацию о проекте")
        return

    text = (
        f"🚀 **{summary['title']}**\n"
        f"{summary['description'] or '📝 Без описания'}\n"
        f"📊 **Статистика:**\n"
        f"• 👥 Участников: {summary['members_count']}\n"
        f"• 📋 Всего задач: {summary['tasks_count']}\n"
        f"• ⏳ К выполнению: {summary['tasks_todo']}\n"
        f"• 🔧 В работе: {summary['tasks_in_progress']}\n"
        f"• ✅ Выполнено: {summary['tasks_done']}\n"
        f"🔐 {'🔒 Приватный' if summary['is_private'] else '🌐 Публичный'}\n"
        f"📋 {'✅ Одобрение не требуется' if not summary['requires_approval'] else '⏳ Требуется одобрение'}\n"
        f"👤 Ваша роль: {summary['user_role']}"
    )

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}#project={project_hash}"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))

    if summary.get('can_manage'):
        builder.row(CallbackButton(text="🔗 Пригласить", payload=f"project_invite:{project_hash}"))
        builder.row(CallbackButton(text="📋 Заявки", payload=f"project_requests:{project_hash}"))

    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_invite(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="❌ Неверная команда")
        return

    project_hash = parts[1]
    invite_link = f"{settings.SITE_URL}/join/{project_hash}"
    text = f"🔗 **Приглашение в проект**\nПроект: **{project_hash}**\nОтправьте эту ссылку пользователям:\n`{invite_link}`\nИли поделитесь хэшем проекта:\n`{project_hash}`"

    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_requests(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="❌ Неверная команда")
        return

    project_hash = parts[1]
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"

    data = await api_client.get_project_join_requests(project_hash, user_id, full_name)
    requests = data.get("requests", [])

    if not requests:
        text = "📋 **Заявки на присоединение**\n\nНет ожидающих заявок."
    else:
        text = "📋 **Заявки на присоединение**\n\n"
        for i, req in enumerate(requests, 1):
            user = req.get("user", {})
            text += f"{i}. {user.get('full_name', 'Аноним')} (ID: {user.get('max_id')})\n"
            text += f"Статус: {req.get('status', 'pending')}\n"
            text += f"Дата: {req.get('requested_at', 'N/A')}\n"
            text += f"---\n"

    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

```

### app\handlers\start.py

```py```
# bot/app/handlers/start.py
from maxapi.types import MessageCreated, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from app.services.api_client import APIClient
from app.config import settings

api_client = APIClient()

async def cmd_start(event: MessageCreated):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))
    builder.row(CallbackButton(text="🔔 Уведомления", payload="notifications"))

    await event.message.answer(
        text=f"👋 Привет, {full_name}!\n"
             f"🚀 **MAX Project Pilot**\n"
             f"Управляйте проектами через веб-приложение или получайте уведомления здесь!\n"
             f"💡 **Основные команды:**\n"
             f"• /create_project - Создать новый проект\n"
             f"• /join <хэш> - Присоединиться к проекту\n"
             f"• /help - Помощь",
        attachments=[builder.as_markup()]
    )

```

### app\services\__init__.py

```py```
# bot/app/services/__init__.py
# Этот файл может быть пустым или содержать базовую инициализацию пакета services
# или импорты для удобства
# from .api_client import APIClient

```

### app\services\api_client.py

```py```
# bot/app/services/api_client.py
import aiohttp
from app.config import settings
from loguru import logger
import json

class APIClient:
    def __init__(self):
        self.base_url = settings.BACKEND_API_URL

    async def get_user_projects(self, user_id: str):
        url = f"{self.base_url}/users/{user_id}/projects"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data.get("projects", [])
                    else:
                        logger.error(f"API Error: {response.status}")
                        return []
        except Exception as e:
            logger.error(f"Network error: {e}")
            return []

    async def create_project(self, user_id: str, full_name: str, title: str, description: str = ""):
        url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._create_project_with_token(title, description, access_token)
        except Exception as e:
            logger.error(f"Error getting token: {e}")
        return None

    async def _create_project_with_token(self, title: str, description: str, token: str):
        url = f"{self.base_url}/projects/"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        data = {"title": title, "description": description}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data, headers=headers) as response:
                    if response.status == 200:
                        project_data = await response.json()
                        return project_data.get("project")
        except Exception as e:
            logger.error(f"Error creating project: {e}")
        return None

    async def get_project_by_hash(self, project_hash: str):
        # Предположим, есть эндпоинт для получения проекта по хэшу без авторизации
        # или с токеном владельца, что сложно в боте. Реализуем как вызов из веб-приложения.
        # В боте можно реализовать только join.
        # Или бот может использовать токен текущего пользователя.
        # Для упрощения, пусть бот использует токен для проверки доступа.
        # Пока возвращаем заглушку.
        pass

    async def request_join_project(self, project_hash: str, user_id: str, full_name: str):
        # Сначала получаем токен
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._request_join_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for join: {e}")
        return {"status": "error", "message": "Failed to get token"}

    async def _request_join_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
                    elif response.status == 404:
                        return {"status": "error", "message": "Project not found"}
                    elif response.status == 400:
                        error_json = await response.json()
                        return {"status": "error", "message": error_json.get("detail", "Already a member")}
        except Exception as e:
            logger.error(f"Error requesting join: {e}")
        return {"status": "error", "message": "Failed to join project"}

    async def get_user_notifications(self, user_id: str):
        # Аналогично, получаем токен и запрашиваем уведомления
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": "Anonymous"} # Имя не важно для получения токена
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_notifications_with_token(access_token)
        except Exception as e:
            logger.error(f"Error getting token for notifications: {e}")
        return {"notifications": []}

    async def get_project_summary(self, project_hash: str, user_id: str, full_name: str):
        """Получение сводки проекта для бота"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_project_summary_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for project summary: {e}")
        return None

    async def _get_project_summary_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/summary"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error getting project summary: {e}")
        return None

    async def get_project_join_requests(self, project_hash: str, user_id: str, full_name: str):
        """Получение запросов на присоединение к проекту"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_project_join_requests_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for join requests: {e}")
        return {"requests": []}

    async def _get_project_join_requests_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error getting join requests: {e}")
        return {"requests": []}

    async def approve_join_request(self, project_hash: str, request_id: int, user_id: str, full_name: str):
        """Одобрение запроса на присоединение"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._approve_join_request_with_token(project_hash, request_id, access_token)
        except Exception as e:
            logger.error(f"Error getting token for approve: {e}")
        return {"status": "error", "message": "Failed to approve"}

    async def _approve_join_request_with_token(self, project_hash: str, request_id: int, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests/{request_id}/approve"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error approving join request: {e}")
        return {"status": "error", "message": "Failed to approve"}

    async def reject_join_request(self, project_hash: str, request_id: int, user_id: str, full_name: str):
        """Отклонение запроса на присоединение"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._reject_join_request_with_token(project_hash, request_id, access_token)
        except Exception as e:
            logger.error(f"Error getting token for reject: {e}")
        return {"status": "error", "message": "Failed to reject"}

    async def _reject_join_request_with_token(self, project_hash: str, request_id: int, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests/{request_id}/reject"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error rejecting join request: {e}")
        return {"status": "error", "message": "Failed to reject"}

```


```

### bot\requirements.txt

```txt```
maxapi==0.9.7
requests==2.32.3
python-dotenv==1.0.1
loguru==0.7.2
aiohttp>=3.12.14
pydantic-settings>=2.0.0
pydantic>=2.0.0

```

### bot\app\__init__.py

```py```
# bot/app/__init__.py
# Этот файл может быть пустым или содержать базовую инициализацию пакета app

```

### bot\app\bot.py

```py```
# bot/app/bot.py
import asyncio
from maxapi import Bot, Dispatcher, F
from maxapi.types import MessageCreated, MessageCallback
from maxapi.filters.command import Command

from app.config import settings
from app.handlers import (
    cmd_start, cmd_create_project, cmd_join_project,
    handle_callback_create_project_start,
    handle_callback_projects,
    handle_callback_project_summary,
    handle_callback_project_invite,
    handle_callback_project_requests,
    handle_callback_notifications
)

bot = Bot(token=settings.BOT_TOKEN)
dp = Dispatcher()

@dp.message_created(Command('start'))
async def handle_start(event: MessageCreated):
    await cmd_start(event)

@dp.message_created(Command('create_project'))
async def handle_create_project(event: MessageCreated):
    await cmd_create_project(event)

@dp.message_created(Command('join'))
async def handle_join_project(event: MessageCreated):
    await cmd_join_project(event)

@dp.message_callback(F.callback.payload.startswith("projects"))
async def handle_projects_callback(event: MessageCallback):
    await handle_callback_projects(event)

@dp.message_callback(F.callback.payload.startswith("project_summary:"))
async def handle_project_summary_callback(event: MessageCallback):
    await handle_callback_project_summary(event)

@dp.message_callback(F.callback.payload.startswith("project_invite:"))
async def handle_project_invite_callback(event: MessageCallback):
    await handle_callback_project_invite(event)

@dp.message_callback(F.callback.payload.startswith("project_requests:"))
async def handle_project_requests_callback(event: MessageCallback):
    await handle_callback_project_requests(event)

@dp.message_callback(F.callback.payload.startswith("notifications"))
async def handle_notifications_callback(event: MessageCallback):
    await handle_callback_notifications(event)

@dp.message_callback(F.callback.payload.startswith("create_project_start"))
async def handle_create_start_callback(event: MessageCallback):
    await handle_callback_create_project_start(event)

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())

```

### bot\app\config.py

```py```
# bot/app/config.py
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    BOT_TOKEN: str
    BACKEND_API_URL: str
    SITE_URL: str = "http://localhost:3000"  # Добавьте эту строку

    class Config:
        env_file = ".env"

settings = Settings()

```

### bot\app\utils.py

```py```
# bot/app/utils.py
import secrets
import string

def generate_invite_hash():
    return ''.join(secrets.choice(string.ascii_lowercase + string.digits) for _ in range(12))

```

### bot\app\handlers\__init__.py

```py```
# bot/app/handlers/__init__.py
from .start import cmd_start
from .projects import (
    cmd_create_project, cmd_join_project,
    handle_callback_create_project_start,
    handle_callback_projects,
    handle_callback_project_summary,
    handle_callback_project_invite,
    handle_callback_project_requests
)
from .notifications import handle_callback_notifications

__all__ = [
    "cmd_start",
    "cmd_create_project",
    "cmd_join_project",
    "handle_callback_create_project_start",
    "handle_callback_projects",
    "handle_callback_project_summary",
    "handle_callback_project_invite",
    "handle_callback_project_requests",
    "handle_callback_notifications"
]

```

### bot\app\handlers\notifications.py

```py```
# bot/app/handlers/notifications.py
from maxapi.types import MessageCallback, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from app.services.api_client import APIClient
from app.config import settings

api_client = APIClient()

async def handle_callback_notifications(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    data = await api_client.get_user_notifications(user_id)
    notifications = data.get("notifications", [])

    if not notifications:
        text = "📭 У вас пока нет уведомлений.\nНовые уведомления появятся здесь, когда в ваших проектах что-то произойдет!"
    else:
        text = "🔔 **Последние уведомления:**\n"
        for i, notification in enumerate(notifications[:5], 1):
            emoji = "🔵" if not notification.get("is_read") else "⚪"
            text += f"{emoji} **{notification.get('title', '')}**\n"
            text += f"{notification.get('message', '')}\n"
            text += "\n"

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={event.from_user.user_id}#notifications"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="🔄 Обновить", payload="notifications"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

```

### bot\app\handlers\projects.py

```py```
# bot/app/handlers/projects.py
from maxapi.types import MessageCreated, MessageCallback, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from maxapi.filters.command import Command
from app.services.api_client import APIClient
from app.utils import generate_invite_hash
from app.config import settings
import re

api_client = APIClient()

async def cmd_create_project(event: MessageCreated):
    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="📁 Начать создание", payload="create_project_start"))
    await event.message.answer("Нажмите кнопку, чтобы начать создание проекта.", attachments=[builder.as_markup()])

async def handle_callback_create_project_start(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}#projects"
    await event.message.answer(f"Для создания проекта перейдите в веб-приложение: {web_app_url}")

async def cmd_join_project(event: MessageCreated):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"
    text = event.message.body.text.strip()

    parts = text.split(" ", 1)
    if len(parts) < 2:
        await event.message.answer("Пожалуйста, укажите хэш проекта. Пример: /join abc123def456")
        return

    project_hash = parts[1]
    if len(project_hash) != 12 or not re.match(r'^[a-z0-9]+$', project_hash):
        await event.message.answer("Неверный формат хэша проекта. Должно быть 12 символов (a-z, 0-9).")
        return

    result = await api_client.request_join_project(project_hash, user_id, full_name)
    if result.get("status") == "joined":
        await event.message.answer("✅ Вы успешно присоединились к проекту!")
    elif result.get("message") == "Join request sent for approval":
        await event.message.answer("📥 Запрос на присоединение отправлен на одобрение!")
    elif result.get("message") == "Already a member of this project":
        await event.message.answer("❌ Вы уже являетесь участником этого проекта.")
    else:
        await event.message.answer(f"❌ {result.get('message', 'Неизвестная ошибка')}")

async def handle_callback_projects(event: MessageCallback):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"
    projects_data = await api_client.get_user_projects(user_id)

    if not projects_data:
        text = "📂 У вас пока нет проектов. Используйте веб-приложение для создания проектов!"
    else:
        text = "📂 **Ваши проекты:**\n"
        for i, member in enumerate(projects_data[:5], 1):
            project = member.get("project", {})
            role_emoji = {"owner": "👑", "admin": "⚡", "member": "👤"}.get(member.get("role"), "👤")
            tasks_count = len(project.get("tasks", []))
            text += f"{i}. {role_emoji} **{project.get('title', 'Без названия')}**\n"
            text += f"📋 {tasks_count} задач | 👥 {len(project.get('members', []))} участников\n"
            text += f"🔗 Хэш: `{project.get('hash', '')}`\n\n"

    builder = InlineKeyboardBuilder()
    for i, member in enumerate(projects_data[:5], 1):
        project = member.get("project", {})
        if member.get("role") in ["owner", "admin"]:
            builder.row(
                CallbackButton(text=f"🔍 {i} - Подробнее", payload=f"project_summary:{project.get('hash')}"),
                CallbackButton(text=f"🔗 {i} - Пригласить", payload=f"project_invite:{project.get('hash')}")
            )

    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="🔄 Обновить", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_summary(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="❌ Неверная команда")
        return

    project_hash = parts[1]
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"

    summary = await api_client.get_project_summary(project_hash, user_id, full_name)
    if not summary:
        await event.answer(notification="❌ Не удалось получить информацию о проекте")
        return

    text = (
        f"🚀 **{summary['title']}**\n"
        f"{summary['description'] or '📝 Без описания'}\n"
        f"📊 **Статистика:**\n"
        f"• 👥 Участников: {summary['members_count']}\n"
        f"• 📋 Всего задач: {summary['tasks_count']}\n"
        f"• ⏳ К выполнению: {summary['tasks_todo']}\n"
        f"• 🔧 В работе: {summary['tasks_in_progress']}\n"
        f"• ✅ Выполнено: {summary['tasks_done']}\n"
        f"🔐 {'🔒 Приватный' if summary['is_private'] else '🌐 Публичный'}\n"
        f"📋 {'✅ Одобрение не требуется' if not summary['requires_approval'] else '⏳ Требуется одобрение'}\n"
        f"👤 Ваша роль: {summary['user_role']}"
    )

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}#project={project_hash}"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))

    if summary.get('can_manage'):
        builder.row(CallbackButton(text="🔗 Пригласить", payload=f"project_invite:{project_hash}"))
        builder.row(CallbackButton(text="📋 Заявки", payload=f"project_requests:{project_hash}"))

    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_invite(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="❌ Неверная команда")
        return

    project_hash = parts[1]
    invite_link = f"{settings.SITE_URL}/join/{project_hash}"
    text = f"🔗 **Приглашение в проект**\nПроект: **{project_hash}**\nОтправьте эту ссылку пользователям:\n`{invite_link}`\nИли поделитесь хэшем проекта:\n`{project_hash}`"

    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

async def handle_callback_project_requests(event: MessageCallback):
    parts = event.callback.payload.split(":", 1)
    if len(parts) != 2:
        await event.answer(notification="❌ Неверная команда")
        return

    project_hash = parts[1]
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"

    data = await api_client.get_project_join_requests(project_hash, user_id, full_name)
    requests = data.get("requests", [])

    if not requests:
        text = "📋 **Заявки на присоединение**\n\nНет ожидающих заявок."
    else:
        text = "📋 **Заявки на присоединение**\n\n"
        for i, req in enumerate(requests, 1):
            user = req.get("user", {})
            text += f"{i}. {user.get('full_name', 'Аноним')} (ID: {user.get('max_id')})\n"
            text += f"Статус: {req.get('status', 'pending')}\n"
            text += f"Дата: {req.get('requested_at', 'N/A')}\n"
            text += f"---\n"

    builder = InlineKeyboardBuilder()
    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))

    await event.bot.edit_message(
        message_id=event.message.body.mid,
        text=text,
        attachments=[builder.as_markup()]
    )

```

### bot\app\handlers\start.py

```py```
# bot/app/handlers/start.py
from maxapi.types import MessageCreated, CallbackButton
from maxapi.utils.inline_keyboard import InlineKeyboardBuilder
from app.services.api_client import APIClient
from app.config import settings

api_client = APIClient()

async def cmd_start(event: MessageCreated):
    user_id = str(event.from_user.user_id)
    full_name = event.from_user.full_name or "Аноним"

    builder = InlineKeyboardBuilder()
    web_app_url = f"{settings.SITE_URL}/?user_id={user_id}"
    builder.row(CallbackButton(text="🌐 Открыть веб-приложение", payload=f"open_webapp:{web_app_url}"))
    builder.row(CallbackButton(text="📋 Мои проекты", payload="projects"))
    builder.row(CallbackButton(text="🔔 Уведомления", payload="notifications"))

    await event.message.answer(
        text=f"👋 Привет, {full_name}!\n"
             f"🚀 **MAX Project Pilot**\n"
             f"Управляйте проектами через веб-приложение или получайте уведомления здесь!\n"
             f"💡 **Основные команды:**\n"
             f"• /create_project - Создать новый проект\n"
             f"• /join <хэш> - Присоединиться к проекту\n"
             f"• /help - Помощь",
        attachments=[builder.as_markup()]
    )

```

### bot\app\services\__init__.py

```py```
# bot/app/services/__init__.py
# Этот файл может быть пустым или содержать базовую инициализацию пакета services
# или импорты для удобства
# from .api_client import APIClient

```

### bot\app\services\api_client.py

```py```
# bot/app/services/api_client.py
import aiohttp
from app.config import settings
from loguru import logger
import json

class APIClient:
    def __init__(self):
        self.base_url = settings.BACKEND_API_URL

    async def get_user_projects(self, user_id: str):
        url = f"{self.base_url}/users/{user_id}/projects"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data.get("projects", [])
                    else:
                        logger.error(f"API Error: {response.status}")
                        return []
        except Exception as e:
            logger.error(f"Network error: {e}")
            return []

    async def create_project(self, user_id: str, full_name: str, title: str, description: str = ""):
        url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._create_project_with_token(title, description, access_token)
        except Exception as e:
            logger.error(f"Error getting token: {e}")
        return None

    async def _create_project_with_token(self, title: str, description: str, token: str):
        url = f"{self.base_url}/projects/"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        data = {"title": title, "description": description}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data, headers=headers) as response:
                    if response.status == 200:
                        project_data = await response.json()
                        return project_data.get("project")
        except Exception as e:
            logger.error(f"Error creating project: {e}")
        return None

    async def get_project_by_hash(self, project_hash: str):
        # Предположим, есть эндпоинт для получения проекта по хэшу без авторизации
        # или с токеном владельца, что сложно в боте. Реализуем как вызов из веб-приложения.
        # В боте можно реализовать только join.
        # Или бот может использовать токен текущего пользователя.
        # Для упрощения, пусть бот использует токен для проверки доступа.
        # Пока возвращаем заглушку.
        pass

    async def request_join_project(self, project_hash: str, user_id: str, full_name: str):
        # Сначала получаем токен
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._request_join_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for join: {e}")
        return {"status": "error", "message": "Failed to get token"}

    async def _request_join_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
                    elif response.status == 404:
                        return {"status": "error", "message": "Project not found"}
                    elif response.status == 400:
                        error_json = await response.json()
                        return {"status": "error", "message": error_json.get("detail", "Already a member")}
        except Exception as e:
            logger.error(f"Error requesting join: {e}")
        return {"status": "error", "message": "Failed to join project"}

    async def get_user_notifications(self, user_id: str):
        # Аналогично, получаем токен и запрашиваем уведомления
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": "Anonymous"} # Имя не важно для получения токена
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_notifications_with_token(access_token)
        except Exception as e:
            logger.error(f"Error getting token for notifications: {e}")
        return {"notifications": []}

    async def get_project_summary(self, project_hash: str, user_id: str, full_name: str):
        """Получение сводки проекта для бота"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_project_summary_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for project summary: {e}")
        return None

    async def _get_project_summary_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/summary"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error getting project summary: {e}")
        return None

    async def get_project_join_requests(self, project_hash: str, user_id: str, full_name: str):
        """Получение запросов на присоединение к проекту"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._get_project_join_requests_with_token(project_hash, access_token)
        except Exception as e:
            logger.error(f"Error getting token for join requests: {e}")
        return {"requests": []}

    async def _get_project_join_requests_with_token(self, project_hash: str, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error getting join requests: {e}")
        return {"requests": []}

    async def approve_join_request(self, project_hash: str, request_id: int, user_id: str, full_name: str):
        """Одобрение запроса на присоединение"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._approve_join_request_with_token(project_hash, request_id, access_token)
        except Exception as e:
            logger.error(f"Error getting token for approve: {e}")
        return {"status": "error", "message": "Failed to approve"}

    async def _approve_join_request_with_token(self, project_hash: str, request_id: int, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests/{request_id}/approve"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error approving join request: {e}")
        return {"status": "error", "message": "Failed to approve"}

    async def reject_join_request(self, project_hash: str, request_id: int, user_id: str, full_name: str):
        """Отклонение запроса на присоединение"""
        token_url = f"{self.base_url}/auth/token"
        token_data = {"max_id": user_id, "full_name": full_name}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(token_url, json=token_data) as response:
                    if response.status == 200:
                        token_response = await response.json()
                        access_token = token_response.get("access_token")
                        if access_token:
                            return await self._reject_join_request_with_token(project_hash, request_id, access_token)
        except Exception as e:
            logger.error(f"Error getting token for reject: {e}")
        return {"status": "error", "message": "Failed to reject"}

    async def _reject_join_request_with_token(self, project_hash: str, request_id: int, token: str):
        url = f"{self.base_url}/projects/{project_hash}/join-requests/{request_id}/reject"
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers) as response:
                    if response.status == 200:
                        return await response.json()
        except Exception as e:
            logger.error(f"Error rejecting join request: {e}")
        return {"status": "error", "message": "Failed to reject"}

```

### web\README.md

```md```
# MAX Project Pilot - Web App

Это статический веб-интерфейс (мини-приложение MAX), который взаимодействует с API вашего сервера.

## Особенности

- Управление проектами и задачами.
- Интеграция с мессенджером MAX.
- Темная/светлая тема.

## Разработка

- `index.html` - основная страница.
- `css/style.css` - стили.
- `js/main.js` - основная логика.
- `js/api.js` - вызовы API.
- `js/auth.js` - авторизация.
- `js/dashboard.js` - дашборд.
- `js/projects.js` - проекты.
- `js/tasks.js` - задачи.

## Деплой

Файлы этого каталога должны быть загружены на GitHub Pages или другой статический хостинг.

```

### web\index.html

```html```
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAX Project Pilot - Управление проектами</title>
    <script src="https://st.max.ru/js/max-web-app.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
</head>
<body class="bg-light">
    <div class="container py-4">
        <header class="max-header mb-4">
            <div class="row align-items-center">
                <div class="col">
                    <h4 class="mb-1"><i class="fas fa-rocket"></i> Project Pilot</h4>
                    <p class="mb-0 small opacity-85">Управление проектами в MAX</p>
                </div>
                <div class="col-auto">
                    <div id="user-info" class="d-flex align-items-center">
                        <div class="user-avatar" id="user-avatar">U</div>
                        <div id="user-name">Гость</div>
                    </div>
                    <button id="theme-toggle" class="btn btn-sm btn-outline-secondary ms-2">
                        <i class="fas fa-moon"></i>
                    </button>
                </div>
            </div>
        </header>

        <!-- Секция авторизации -->
        <div id="authSection" class="auth-section">
            <h5 class="mb-3">🔐 Вход в систему</h5>
            <p class="text-muted mb-3">Для работы с приложением необходимо авторизоваться</p>
            <div class="mb-3">
                <label for="userIdInput" class="form-label">Ваш User ID:</label>
                <input type="text" class="form-control" id="userIdInput" placeholder="Введите ваш User ID">
                <div class="form-text">User ID можно получить в боте @max_project_pilot_bot командой /start</div>
            </div>
            <button class="btn max-btn-primary w-100 mb-2" onclick="login()"><i class="fas fa-sign-in-alt"></i> Войти</button>
            <div class="mt-3">
                <small class="text-muted">Нет User ID? <a href="https://t.me/max_project_pilot_bot" target="_blank" class="text-primary">Получить в боте</a></small>
            </div>
        </div>

        <!-- Основной интерфейс (скрыт до авторизации) -->
        <div id="mainInterface" style="display: none;">
            <!-- Навигация -->
            <ul class="nav nav-tabs nav-tabs-max nav-justified mb-4">
                <li class="nav-item">
                    <a class="nav-link active" href="#" onclick="showSection('dashboard')"><i class="fas fa-home"></i><span class="d-none d-md-inline"> Главная</span></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#" onclick="showSection('projects')"><i class="fas fa-project-diagram"></i><span class="d-none d-md-inline"> Проекты</span></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#" onclick="showSection('tasks')"><i class="fas fa-tasks"></i><span class="d-none d-md-inline"> Задачи</span></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#" onclick="showSection('notifications')"><i class="fas fa-bell"></i><span class="d-none d-md-inline"> Уведомления</span></a>
                </li>
            </ul>

            <!-- Секция: Главная -->
            <div id="dashboard" class="section active">
                <div class="row mb-4">
                    <div class="col-md-3">
                        <div class="max-card p-3 text-center">
                            <h5 id="projects-count">0</h5>
                            <p class="text-muted mb-0">Проектов</p>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="max-card p-3 text-center">
                            <h5 id="tasks-todo-count">0</h5>
                            <p class="text-muted mb-0">К выполнению</p>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="max-card p-3 text-center">
                            <h5 id="tasks-progress-count">0</h5>
                            <p class="text-muted mb-0">В работе</p>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="max-card p-3 text-center">
                            <h5 id="tasks-done-count">0</h5>
                            <p class="text-muted mb-0">Выполнено</p>
                        </div>
                    </div>
                </div>
                <div class="max-card p-4">
                    <h6 class="mb-3">📊 Статистика проектов</h6>
                    <div id="dashboard-projects-list">
                        <!-- Динамически загружается -->
                    </div>
                </div>
            </div>

            <!-- Секция: Проекты -->
            <div id="projects" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h6 class="mb-0">Мои проекты</h6>
                    <button class="btn max-btn-primary btn-sm" onclick="createProject()"><i class="fas fa-plus"></i> Новый</button>
                </div>
                <div id="projects-list">
                    <div class="loading"><i class="fas fa-spinner fa-spin"></i> Загрузка проектов...</div>
                </div>
            </div>

            <!-- Секция: Задачи -->
            <div id="tasks" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h6 class="mb-0">Все задачи</h6>
                    <div>
                        <button class="btn max-btn-primary btn-sm me-2" onclick="loadTasks('todo')"><i class="fas fa-hourglass-start"></i> К выполнению</button>
                        <button class="btn max-btn-primary btn-sm me-2" onclick="loadTasks('in_progress')"><i class="fas fa-cogs"></i> В работе</button>
                        <button class="btn max-btn-primary btn-sm" onclick="loadTasks('done')"><i class="fas fa-check-circle"></i> Завершено</button>
                    </div>
                </div>
                <div class="input-group mb-3">
                    <input type="text" id="searchTasksInput" class="form-control" placeholder="Поиск задач...">
                    <button class="btn btn-outline-secondary" type="button" onclick="searchTasks()"><i class="fas fa-search"></i></button>
                </div>
                <div id="tasks-list">
                    <div class="loading"><i class="fas fa-spinner fa-spin"></i> Загрузка задач...</div>
                </div>
            </div>

            <!-- Секция: Уведомления -->
            <div id="notifications" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h6 class="mb-0">Уведомления</h6>
                    <button class="btn btn-outline-secondary btn-sm" onclick="markAllNotificationsRead()"><i class="fas fa-check-double"></i> Прочитать все</button>
                </div>
                <div id="notifications-list">
                    <div class="loading"><i class="fas fa-spinner fa-spin"></i> Загрузка уведомлений...</div>
                </div>
            </div>
        </div>

        <!-- Модальное окно для задачи -->
        <div class="modal fade" id="taskModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="taskModalTitle">Задача</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <h6 id="taskModalProjectTitle"></h6>
                        <p id="taskModalDescription" contenteditable="true" oninput="debounceSaveTaskDescription()"></p>
                        <div class="mb-3">
                            <label class="form-label">Статус</label>
                            <select id="taskModalStatus" class="form-select">
                                <option value="todo">К выполнению</option>
                                <option value="in_progress">В работе</option>
                                <option value="done">Завершено</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Исполнители</label>
                            <select multiple class="form-select" id="taskModalAssignees"></select>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Подзадачи</label>
                            <div id="taskModalSubtasks">
                                <!-- Динамически добавляются -->
                            </div>
                            <button class="btn btn-sm btn-outline-secondary mt-1" onclick="addSubtask()">+ Добавить подзадачу</button>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Комментарии</label>
                            <div id="taskModalComments">
                                <!-- Динамически добавляются -->
                            </div>
                            <div class="input-group mt-2">
                                <textarea id="newCommentText" class="form-control" placeholder="Написать комментарий..."></textarea>
                                <button class="btn btn-primary" onclick="addComment()">Отправить</button>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Файлы</label>
                            <div id="taskModalFiles">
                                <!-- Ссылки на файлы -->
                            </div>
                            <input type="file" id="fileUploadInput" class="form-control" multiple>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                        <button type="button" class="btn btn-primary" onclick="updateTask()">Сохранить</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.6.2/fuse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="js/main.js"></script>
</body>
</html>

```

### web\css\style.css

```css```
/* web/css/style.css */
:root {
    --primary-color: #4361ee;
    --secondary-color: #3a0ca3;
    --success-color: #4cc9f0;
    --danger-color: #f72585;
    --warning-color: #f8961e;
    --max-bg: #f0f2f5;
    --max-card-bg: #ffffff;
    --max-text: #1c1e21;
    --max-border: #dddfe2;
}

body {
    background-color: var(--max-bg);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding-top: 20px;
    padding-bottom: 20px;
}

.navbar-brand {
    font-weight: 600;
    font-size: 1.5rem;
}

.navbar-brand i {
    margin-right: 0.5rem;
}

.max-card {
    background-color: var(--max-card-bg);
    border: 1px solid var(--max-border);
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.max-btn-primary {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

.max-btn-primary:hover {
    background-color: #3651d8;
    border-color: #3651d8;
}

.nav-tabs-max .nav-link {
    color: #6c757d;
    border: 1px solid transparent;
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
}

.nav-tabs-max .nav-link.active {
    color: var(--primary-color);
    background-color: var(--max-card-bg);
    border-color: var(--max-border) var(--max-border) var(--max-card-bg);
}

.project-card, .task-item {
    cursor: pointer;
    transition: background-color 0.2s;
}

.project-card:hover, .task-item:hover {
    background-color: rgba(67, 97, 238, 0.05);
}

.task-item.todo { border-left: 4px solid var(--warning-color); }
.task-item.in_progress { border-left: 4px solid var(--success-color); }
.task-item.done { border-left: 4px solid var(--danger-color); }

.user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: var(--primary-color);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    margin-right: 10px;
}

.loading {
    text-align: center;
    padding: 20px;
    color: #6c757d;
}

.progress-bar {
    background-color: var(--primary-color);
}

/* Темная тема */
body.dark-theme {
    background-color: #121212;
    color: #e0e0e0;
}

.dark-theme .max-card {
    background-color: #1e1e1e;
    border-color: #444444;
    color: #e0e0e0;
}

.dark-theme .nav-tabs-max .nav-link {
    color: #b0b0b0;
}

.dark-theme .nav-tabs-max .nav-link.active {
    color: var(--primary-color);
    background-color: #1e1e1e;
    border-color: #444444 #444444 #1e1e1e;
}

.dark-theme .form-control, .dark-theme .form-select {
    background-color: #2d2d2d;
    border-color: #444444;
    color: #e0e0e0;
}

.dark-theme .form-control:focus, .dark-theme .form-select:focus {
    background-color: #2d2d2d;
    border-color: var(--primary-color);
    color: #e0e0e0;
    box-shadow: 0 0 0 0.2rem rgba(67, 97, 238, 0.25);
}

.dark-theme .btn-close {
    filter: invert(1);
}

```

### web\js\api.js

```js```
// web/js/api.js
// Конфигурация
const API_BASE_URL = 'http://localhost:8000/api'; // Заменить на URL вашего сервера

// Универсальный вызов API
async function apiCall(endpoint, method = 'GET', data = null, token = null) {
    const url = `${API_BASE_URL}${endpoint}`;
    const headers = {
        'Content-Type': 'application/json',
    };
    if (token) {
        headers['Authorization'] = `Bearer ${token}`;
    }

    const config = {
        method,
        headers,
    };

    if (data) {
        config.body = JSON.stringify(data);
    }

    try {
        const response = await fetch(url, config);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('API Error:', error);
        throw error;
    }
}

// Экспортируем функции для использования в других модулях
// В старом коде они были глобальными, в новом можно экспортировать
// export { apiCall, login, getProjects, createProject, getTasks, getProjectTasks, createTask, updateTaskStatus, getNotifications, markAllNotificationsRead };

```

### web\js\auth.js

```js```
// web/js/auth.js
// import { apiCall } from './api.js'; // Если используем ES6 modules

// Глобальные переменные (если не используем модули)
let currentUserId = null;

// Функция входа
async function login(userId, fullName) {
    try {
        const response = await apiCall('/auth/token', 'POST', { max_id: userId, full_name: fullName });
        if (response.access_token) {
            localStorage.setItem('access_token', response.access_token);
            localStorage.setItem('user_id', response.user.id);
            localStorage.setItem('user_name', response.user.full_name);
            currentUserId = response.user.id;
            return response.user;
        }
        return null;
    } catch (error) {
        console.error('Login error:', error);
        throw error;
    }
}

// Проверка авторизации при загрузке
window.addEventListener('load', () => {
    const token = localStorage.getItem('access_token');
    if (token) {
        currentUserId = localStorage.getItem('user_id');
        if (currentUserId) {
            showMainInterface();
        } else {
            showAuthSection();
        }
    } else {
        showAuthSection();
    }
});

// Функции показа интерфейса (предполагаем, что они определены в main.js)
function showAuthSection() {
    document.getElementById('authSection').style.display = 'block';
    document.getElementById('mainInterface').style.display = 'none';
}

function showMainInterface() {
    document.getElementById('authSection').style.display = 'none';
    document.getElementById('mainInterface').style.display = 'block';
    document.getElementById('user-name').textContent = localStorage.getItem('user_name');
    document.getElementById('user-avatar').textContent = localStorage.getItem('user_name').charAt(0).toUpperCase();
}

// Функция вызова из main.js
async function login() {
    const userId = document.getElementById('userIdInput').value.trim();
    if (!userId) {
        alert('Введите User ID');
        return;
    }
    // Для простоты, используем 'Anonymous' как имя, если не получено из MAX
    const fullName = prompt('Введите ваше имя (для регистрации):') || 'Anonymous';
    try {
        const user = await login(userId, fullName); // Вызываем локальную функцию login
        if (user) {
            showMainInterface();
            await loadDashboardData();
            await loadProjects();
            await loadTasks();
            await loadNotifications();
        } else {
            alert('Ошибка входа');
        }
    } catch (error) {
        console.error('Login error:', error);
        alert('Ошибка входа: ' + error.message);
    }
}

```

### web\js\dashboard.js

```js```
// web/js/dashboard.js
// import { getProjects, getTasks } from './api.js'; // Если используем ES6 modules

async function loadDashboardData() {
    if (!currentUserId) return;
    const token = localStorage.getItem('access_token');
    try {
        const projectsData = await getProjects(currentUserId, token); // Предполагаем, что getProjects определена в api.js или импортирована
        const tasksData = await getTasks(currentUserId, token); // Предполагаем, что getTasks определена в api.js или импортирована

        const projectsCount = projectsData.projects ? projectsData.projects.length : 0;
        const tasks = tasksData.tasks || [];

        const tasksTodo = tasks.filter(t => t.status === 'todo').length;
        const tasksProgress = tasks.filter(t => t.status === 'in_progress').length;
        const tasksDone = tasks.filter(t => t.status === 'done').length;

        document.getElementById('projects-count').textContent = projectsCount;
        document.getElementById('tasks-todo-count').textContent = tasksTodo;
        document.getElementById('tasks-progress-count').textContent = tasksProgress;
        document.getElementById('tasks-done-count').textContent = tasksDone;

        const container = document.getElementById('dashboard-projects-list');
        if (projectsData.projects && projectsData.projects.length > 0) {
            container.innerHTML = projectsData.projects.map(member => {
                const project = member.project;
                const stats = project.stats || { tasks_count: 0, tasks_done: 0 };
                const progress = stats.tasks_count > 0 ? Math.round((stats.tasks_done / stats.tasks_count) * 100) : 0;
                return `
                    <div class="project-card mb-2 p-2" onclick="openProject('${project.hash}')">
                        <div class="d-flex justify-content-between align-items-center">
                            <h6 class="mb-0">${project.title}</h6>
                            <span class="badge bg-${member.role === 'owner' ? 'primary' : 'secondary'}">${member.role}</span>
                        </div>
                        <div class="progress mb-1" style="height: 8px;">
                            <div class="progress-bar" style="width: ${progress}%"></div>
                        </div>
                        <small class="text-muted">${progress}% завершено (${stats.tasks_done}/${stats.tasks_count})</small>
                    </div>
                `;
            }).join('');
        } else {
            container.innerHTML = '<p class="text-muted">Нет проектов для отображения.</p>';
        }
    } catch (error) {
        console.error('Dashboard load error:', error);
        document.getElementById('projects-count').textContent = '0';
        document.getElementById('tasks-todo-count').textContent = '0';
        document.getElementById('tasks-progress-count').textContent = '0';
        document.getElementById('tasks-done-count').textContent = '0';
        document.getElementById('dashboard-projects-list').innerHTML = '<p class="text-muted">Ошибка загрузки данных.</p>';
    }
}

```

### web\js\main.js

```js```
// web/js/main.js
// --- Конфигурация ---
const API_BASE_URL = 'http://localhost:8000/api'; // Заменить на URL вашего сервера
let currentUserId = null;
let currentSection = 'dashboard';
let currentTheme = localStorage.getItem('theme') || 'light';

// --- Утилиты ---
function escapeHTML(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('ru-RU');
}

function getStatusColor(status) {
    const colors = {'todo': 'warning', 'in_progress': 'info', 'done': 'success'};
    return colors[status] || 'secondary';
}

function getStatusText(status) {
    const texts = {'todo': 'К выполнению', 'in_progress': 'В работе', 'done': 'Завершено'};
    return texts[status] || status;
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// --- Тема ---
function applyTheme() {
    const body = document.body;
    const icon = document.querySelector('#theme-toggle i');

    if (currentTheme === 'dark') {
        body.classList.add('dark-theme');
        icon.classList.remove('fa-moon');
        icon.classList.add('fa-sun');
    } else {
        body.classList.remove('dark-theme');
        icon.classList.remove('fa-sun');
        icon.classList.add('fa-moon');
    }
}

function toggleTheme() {
    currentTheme = currentTheme === 'light' ? 'dark' : 'light';
    localStorage.setItem('theme', currentTheme);
    applyTheme();
}

document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
applyTheme(); // Применить тему при загрузке

// --- API ---
async function apiCall(endpoint, method = 'GET', data = null, token = null) {
    const url = `${API_BASE_URL}${endpoint}`;
    const headers = {
        'Content-Type': 'application/json',
    };
    if (token) {
        headers['Authorization'] = `Bearer ${token}`;
    }

    const config = {
        method,
        headers,
    };

    if (data) {
        config.body = JSON.stringify(data);
    }

    try {
        const response = await fetch(url, config);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('API Error:', error);
        throw error;
    }
}

// Auth
async function login(userId, fullName) {
    const response = await apiCall('/auth/token', 'POST', { max_id: userId, full_name: fullName });
    if (response.access_token) {
        localStorage.setItem('access_token', response.access_token);
        localStorage.setItem('user_id', response.user.id);
        localStorage.setItem('user_name', response.user.full_name);
        currentUserId = response.user.id;
        return response.user;
    }
    return null;
}

// Projects
async function getProjects(userId, token) {
    return await apiCall(`/users/${userId}/projects`, 'GET', null, token);
}

async function createProject(title, description, token) {
    return await apiCall('/projects/', 'POST', { title, description }, token);
}

// Tasks
async function getTasks(userId, token) {
    return await apiCall(`/tasks/?user_id=${userId}`, 'GET', null, token);
}

async function getProjectTasks(projectHash, token) {
    return await apiCall(`/tasks/project/${projectHash}`, 'GET', null, token);
}

async function createTask(title, projectHash, description, status, priority, assignedToIds, token) {
    return await apiCall('/tasks/', 'POST', { title, project_hash: projectHash, description, status, priority, assigned_to_ids: assignedToIds }, token);
}

async function updateTaskStatus(taskId, status, token) {
    return await apiCall(`/tasks/${taskId}/status`, 'PUT', { status }, token);
}

// Notifications
async function getNotifications(userId, token) {
    return await apiCall(`/notifications/?user_id=${userId}`, 'GET', null, token);
}

async function markAllNotificationsRead(userId, token) {
    return await apiCall('/notifications/mark_all_read', 'PUT', null, token);
}

// --- Авторизация ---
function showAuthSection() {
    document.getElementById('authSection').style.display = 'block';
    document.getElementById('mainInterface').style.display = 'none';
}

function showMainInterface() {
    document.getElementById('authSection').style.display = 'none';
    document.getElementById('mainInterface').style.display = 'block';
    document.getElementById('user-name').textContent = localStorage.getItem('user_name');
    document.getElementById('user-avatar').textContent = localStorage.getItem('user_name').charAt(0).toUpperCase();
}

async function login() {
    const userId = document.getElementById('userIdInput').value.trim();
    if (!userId) {
        alert('Введите User ID');
        return;
    }
    // Для простоты, используем 'Anonymous' как имя, если не получено из MAX
    const fullName = prompt('Введите ваше имя (для регистрации):') || 'Anonymous';
    try {
        const user = await login(userId, fullName);
        if (user) {
            showMainInterface();
            await loadDashboardData();
            await loadProjects();
            await loadTasks();
            await loadNotifications();
        } else {
            alert('Ошибка входа');
        }
    } catch (error) {
        console.error('Login error:', error);
        alert('Ошибка входа: ' + error.message);
    }
}

// Проверка авторизации при загрузке
window.addEventListener('load', () => {
    const token = localStorage.getItem('access_token');
    if (token) {
        currentUserId = localStorage.getItem('user_id');
        if (currentUserId) {
            showMainInterface();
            // Загрузка данных может быть вызвана позже
        } else {
            showAuthSection();
        }
    } else {
        showAuthSection();
    }
});

// --- Секции ---
async function showSection(sectionName) {
    if (!currentUserId) {
        alert('Пожалуйста, войдите в систему');
        return;
    }

    // Скрыть все секции
    document.querySelectorAll('.section').forEach(section => {
        section.classList.remove('active');
    });
    // Показать выбранную
    document.getElementById(sectionName).classList.add('active');

    // Обновить активную вкладку
    document.querySelectorAll('.nav-link').forEach(link => {
        link.classList.remove('active');
    });
    event.target.classList.add('active');

    currentSection = sectionName;

    // Загрузить данные для секции
    switch(sectionName) {
        case 'dashboard':
            await loadDashboardData();
            break;
        case 'projects':
            await loadProjects();
            break;
        case 'tasks':
            await loadTasks();
            break;
        case 'notifications':
            await loadNotifications();
            break;
    }
}

// --- Дашборд ---
async function loadDashboardData() {
    if (!currentUserId) return;
    const token = localStorage.getItem('access_token');
    try {
        const projectsData = await getProjects(currentUserId, token);
        const tasksData = await getTasks(currentUserId, token);

        const projectsCount = projectsData.projects ? projectsData.projects.length : 0;
        const tasks = tasksData.tasks || [];

        const tasksTodo = tasks.filter(t => t.status === 'todo').length;
        const tasksProgress = tasks.filter(t => t.status === 'in_progress').length;
        const tasksDone = tasks.filter(t => t.status === 'done').length;

        document.getElementById('projects-count').textContent = projectsCount;
        document.getElementById('tasks-todo-count').textContent = tasksTodo;
        document.getElementById('tasks-progress-count').textContent = tasksProgress;
        document.getElementById('tasks-done-count').textContent = tasksDone;

        const container = document.getElementById('dashboard-projects-list');
        if (projectsData.projects && projectsData.projects.length > 0) {
            container.innerHTML = projectsData.projects.map(member => {
                const project = member.project;
                const stats = project.stats || { tasks_count: 0, tasks_done: 0 };
                const progress = stats.tasks_count > 0 ? Math.round((stats.tasks_done / stats.tasks_count) * 100) : 0;
                return `
                    <div class="project-card mb-2 p-2" onclick="openProject('${project.hash}')">
                        <div class="d-flex justify-content-between align-items-center">
                            <h6 class="mb-0">${project.title}</h6>
                            <span class="badge bg-${member.role === 'owner' ? 'primary' : 'secondary'}">${member.role}</span>
                        </div>
                        <div class="progress mb-1" style="height: 8px;">
                            <div class="progress-bar" style="width: ${progress}%"></div>
                        </div>
                        <small class="text-muted">${progress}% завершено (${stats.tasks_done}/${stats.tasks_count})</small>
                    </div>
                `;
            }).join('');
        } else {
            container.innerHTML = '<p class="text-muted">Нет проектов для отображения.</p>';
        }
    } catch (error) {
        console.error('Dashboard load error:', error);
        document.getElementById('projects-count').textContent = '0';
        document.getElementById('tasks-todo-count').textContent = '0';
        document.getElementById('tasks-progress-count').textContent = '0';
        document.getElementById('tasks-done-count').textContent = '0';
        document.getElementById('dashboard-projects-list').innerHTML = '<p class="text-muted">Ошибка загрузки данных.</p>';
    }
}

// --- Проекты ---
async function loadProjects() {
    if (!currentUserId) {
        document.getElementById('projects-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-exclamation-triangle fa-2x text-muted mb-3"></i>
                <h6>Необходима авторизация</h6>
                <p class="text-muted">Для просмотра проектов войдите в систему</p>
            </div>`;
        return;
    }
    const token = localStorage.getItem('access_token');
    try {
        const data = await getProjects(currentUserId, token);
        const container = document.getElementById('projects-list');

        if (!data.projects || data.projects.length === 0) {
            container.innerHTML = `
                <div class="max-card text-center">
                    <i class="fas fa-folder-open fa-2x text-muted mb-3"></i>
                    <h6>Проектов пока нет</h6>
                    <p class="text-muted">Создайте свой первый проект!</p>
                    <button class="btn max-btn-primary" onclick="createProject()"><i class="fas fa-plus"></i> Создать проект</button>
                </div>`;
            return;
        }

        container.innerHTML = data.projects.map(member => {
            const project = member.project;
            const stats = project.stats || { tasks_count: 0, tasks_done: 0 };
            const progress = stats.tasks_count > 0 ? Math.round((stats.tasks_done / stats.tasks_count) * 100) : 0;
            return `
                <div class="project-card max-card" onclick="openProject('${project.hash}')">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h6 class="mb-0">${project.title}</h6>
                        <span class="badge bg-${member.role === 'owner' ? 'primary' : 'secondary'}">${member.role}</span>
                    </div>
                    <p class="text-muted mb-1">${project.description || 'Без описания'}</p>
                    <div class="d-flex justify-content-between align-items-center">
                        <small class="text-muted">Участников: ${project.members ? project.members.length : 0}</small>
                        <small class="text-muted">Задач: ${stats.tasks_count}</small>
                    </div>
                    <div class="progress mt-2" style="height: 8px;">
                        <div class="progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <small class="text-muted">${progress}% завершено</small>
                </div>`;
        }).join('');

    } catch (error) {
        console.error('Projects load error:', error);
        document.getElementById('projects-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-exclamation-triangle fa-2x text-muted mb-3"></i>
                <h6>Ошибка загрузки</h6>
                <p class="text-muted">Не удалось загрузить проекты</p>
            </div>`;
    }
}

async function createProject() {
    if (!currentUserId) {
        alert('Необходима авторизация для создания проекта');
        return;
    }
    const title = prompt('Введите название проекта:');
    if (!title) return;
    const description = prompt('Введите описание проекта (необязательно):') || '';

    const token = localStorage.getItem('access_token');
    try {
        const result = await createProject(title, description, token);
        alert(`Проект "${result.project.title}" создан!`);
        if (currentSection === 'projects') {
            await loadProjects();
        }
        await loadDashboardData(); // Обновить счётчики
    } catch (error) {
        console.error('Project creation error:', error);
        alert('Ошибка при создании проекта: ' + error.message);
    }
}

function openProject(projectHash) {
    // Здесь можно открыть модальное окно с деталями проекта или перейти на страницу проекта
    // Пока просто покажем QR-код для приглашения
    showProjectInviteQR(projectHash);
}

function showProjectInviteQR(projectHash) {
    const inviteUrl = `${window.location.origin}/?join=${projectHash}`;
    const modal = new bootstrap.Modal(document.createElement('div'));
    const modalHTML = `
        <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Пригласить в проект</h5>
                        <button type="button" class="btn-close" onclick="this.closest('.modal').remove()"></button>
                    </div>
                    <div class="modal-body text-center">
                        <p>Отправьте этот QR-код пользователю:</p>
                        <div id="qrCodeContainer"></div>
                        <p class="mt-2">Или поделитесь ссылкой: <code>${inviteUrl}</code></p>
                    </div>
                </div>
            </div>
        </div>`;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    const modalElement = document.querySelector('.modal.show');
    new QRCode(document.getElementById('qrCodeContainer'), { text: inviteUrl, width: 200, height: 200 });
    modalElement.querySelector('.btn-close').addEventListener('click', () => modalElement.remove());
}

// --- Задачи ---
let currentTaskId = null;
let currentTaskDetails = null;
let taskSearchFuse = null;

async function loadTasks(status = null) {
    if (!currentUserId) {
        document.getElementById('tasks-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-tasks fa-2x text-muted mb-3"></i>
                <h6>Необходима авторизация</h6>
                <p class="text-muted">Для просмотра задач войдите в систему</p>
            </div>`;
        return;
    }
    const token = localStorage.getItem('access_token');
    try {
        const data = await getTasks(currentUserId, token);
        const tasks = data.tasks || [];

        // Фильтрация по статусу
        const filteredTasks = status ? tasks.filter(t => t.status === status) : tasks;

        const container = document.getElementById('tasks-list');
        if (filteredTasks.length === 0) {
            container.innerHTML = `
                <div class="max-card text-center">
                    <i class="fas fa-tasks fa-2x text-muted mb-3"></i>
                    <h6>Задач пока нет</h6>
                    <p class="text-muted">Создайте первую задачу в проекте!</p>
                </div>`;
            return;
        }

        container.innerHTML = filteredTasks.map(task => {
            const statusColor = getStatusColor(task.status);
            const statusText = getStatusText(task.status);
            return `
                <div class="task-item task-${task.status} max-card" onclick="openTaskModal(${task.id})">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <h6 class="mb-0">${task.title}</h6>
                            <p class="text-muted small mb-1">${task.description ? task.description.substring(0, 50) + '...' : ''}</p>
                            <div class="d-flex align-items-center">
                                <span class="badge bg-${statusColor} me-2">${statusText}</span>
                                <span class="text-muted small">${formatDate(task.created_at)}</span>
                            </div>
                        </div>
                        <div class="text-end">
                            <div class="text-muted small">Проект: ${task.project.title}</div>
                            <div class="text-muted small">Приоритет: ${task.priority}</div>
                        </div>
                    </div>
                </div>`;
        }).join('');

        // Инициализация поиска
        taskSearchFuse = new Fuse(tasks, {
            keys: ['title', 'description'],
            threshold: 0.3
        });

    } catch (error) {
        console.error('Tasks load error:', error);
        document.getElementById('tasks-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-exclamation-triangle fa-2x text-muted mb-3"></i>
                <h6>Ошибка загрузки</h6>
                <p class="text-muted">Не удалось загрузить задачи</p>
            </div>`;
    }
}

function openTaskModal(taskId) {
    currentTaskId = taskId;
    // Загрузка деталей задачи и открытие модального окна
    // Пока упрощённо
    const token = localStorage.getItem('access_token');
    fetch(`${API_BASE_URL}/tasks/${taskId}`, {
        headers: { 'Authorization': `Bearer ${token}` }
    })
    .then(response => response.json())
    .then(data => {
        currentTaskDetails = data.task;
        document.getElementById('taskModalTitle').textContent = data.task.title;
        document.getElementById('taskModalProjectTitle').textContent = data.task.project.title;
        document.getElementById('taskModalDescription').textContent = data.task.description || '';
        document.getElementById('taskModalStatus').value = data.task.status;

        // Заполнение assignees
        const assigneeSelect = document.getElementById('taskModalAssignees');
        assigneeSelect.innerHTML = '';
        data.task.project.members.forEach(member => {
            const option = document.createElement('option');
            option.value = member.user_id;
            option.textContent = member.user.full_name;
            if (data.task.assigned_to_id === member.user_id) option.selected = true;
            assigneeSelect.appendChild(option);
        });

        // Заполнение подзадач
        const subtasksContainer = document.getElementById('taskModalSubtasks');
        subtasksContainer.innerHTML = data.task.subtasks ? data.task.subtasks.map(st => `
            <div class="form-check">
                <input class="form-check-input" type="checkbox" value="" id="subtask${st.id}" ${st.status === 'done' ? 'checked' : ''} disabled>
                <label class="form-check-label" for="subtask${st.id}">${st.title}</label>
            </div>
        `).join('') : '';

        // Заполнение комментариев
        const commentsContainer = document.getElementById('taskModalComments');
        commentsContainer.innerHTML = data.task.comments ? data.task.comments.map(c => `
            <div class="comment-item mb-2">
                <strong>${c.user.full_name}</strong> <small class="text-muted">${formatDate(c.created_at)}</small>
                <p class="mb-1">${escapeHTML(c.content)}</p>
            </div>
        `).join('') : '';

        // Заполнение файлов
        const filesContainer = document.getElementById('taskModalFiles');
        filesContainer.innerHTML = data.task.attachments ? data.task.attachments.map(att => `
            <a href="${att.url}" target="_blank">${att.filename}</a>
        `).join('<br>') : 'Нет прикреплённых файлов';

        const modal = new bootstrap.Modal(document.getElementById('taskModal'));
        modal.show();
    })
    .catch(err => console.error('Error loading task details:', err));
}

function updateTask() {
    if (!currentUserId || !currentTaskId) return;
    const token = localStorage.getItem('access_token');
    const newStatus = document.getElementById('taskModalStatus').value;
    updateTaskStatus(currentTaskId, newStatus, token)
        .then(() => {
            alert('Задача обновлена!');
            const modal = bootstrap.Modal.getInstance(document.getElementById('taskModal'));
            modal.hide();
            if (currentSection === 'tasks') {
                loadTasks(); // Перезагрузить задачи
            }
        })
        .catch(err => {
            console.error('Update task error:', err);
            alert('Ошибка обновления задачи');
        });
}

function debounceSaveTaskDescription() {
    debounce(async () => {
        if (!currentTaskId) return;
        const newDesc = document.getElementById('taskModalDescription').textContent;
        // Реализовать PUT запрос для обновления описания
        // PUT /api/tasks/{id}/description
        // console.log('Saving description for task', currentTaskId, ':', newDesc);
    }, 500)();
}

function addSubtask() {
    const title = prompt('Введите название подзадачи:');
    if (title) {
        // Реализовать POST запрос для создания подзадачи
        // POST /api/tasks/
        // console.log('Adding subtask:', title, 'to task', currentTaskId);
    }
}

function addComment() {
    const text = document.getElementById('newCommentText').value.trim();
    if (!text) return;
    // Реализовать POST запрос для создания комментария
    // POST /api/tasks/{id}/comments
    // console.log('Adding comment:', text, 'to task', currentTaskId);
    document.getElementById('newCommentText').value = '';
}

function searchTasks() {
    const query = document.getElementById('searchTasksInput').value;
    if (!taskSearchFuse || !query) {
        loadTasks(); // Показать все задачи, если нет запроса
        return;
    }
    const results = taskSearchFuse.search(query);
    const container = document.getElementById('tasks-list');
    if (results.length === 0) {
        container.innerHTML = '<p class="text-muted">Задачи не найдены.</p>';
        return;
    }
    container.innerHTML = results.map(result => {
        const task = result.item;
        const statusColor = getStatusColor(task.status);
        const statusText = getStatusText(task.status);
        return `
            <div class="task-item task-${task.status} max-card" onclick="openTaskModal(${task.id})">
                <div class="d-flex justify-content-between align-items-start">
                    <div class="flex-grow-1">
                        <h6 class="mb-0">${task.title}</h6>
                        <p class="text-muted small mb-1">${task.description ? task.description.substring(0, 50) + '...' : ''}</p>
                        <div class="d-flex align-items-center">
                            <span class="badge bg-${statusColor} me-2">${statusText}</span>
                            <span class="text-muted small">${formatDate(task.created_at)}</span>
                        </div>
                    </div>
                    <div class="text-end">
                        <div class="text-muted small">Проект: ${task.project.title}</div>
                        <div class="text-muted small">Приоритет: ${task.priority}</div>
                    </div>
                </div>
            </div>`;
    }).join('');
}

// --- Уведомления ---
async function loadNotifications() {
    if (!currentUserId) {
        document.getElementById('notifications-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-bell fa-2x text-muted mb-3"></i>
                <h6>Необходима авторизация</h6>
                <p class="text-muted">Для просмотра уведомлений войдите в систему</p>
            </div>`;
        return;
    }
    const token = localStorage.getItem('access_token');
    try {
        const data = await getNotifications(currentUserId, token);
        const container = document.getElementById('notifications-list');

        if (!data.notifications || data.notifications.length === 0) {
            container.innerHTML = `
                <div class="max-card text-center">
                    <i class="fas fa-inbox fa-2x text-muted mb-3"></i>
                    <h6>Уведомлений нет</h6>
                    <p class="text-muted">Новые уведомления появятся здесь</p>
                </div>`;
            return;
        }

        container.innerHTML = data.notifications.map(notification => {
            const unreadClass = notification.is_read ? '' : 'fw-bold';
            const unreadIcon = notification.is_read ? '⚪' : '🔵';
            return `
                <div class="max-card ${unreadClass}">
                    <div class="d-flex justify-content-between">
                        <h6 class="mb-0">${unreadIcon} ${notification.title}</h6>
                        <small class="text-muted">${formatDate(notification.created_at)}</small>
                    </div>
                    <p class="mb-0">${notification.message}</p>
                </div>`;
        }).join('');

    } catch (error) {
        console.error('Notifications load error:', error);
        document.getElementById('notifications-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-exclamation-triangle fa-2x text-muted mb-3"></i>
                <h6>Ошибка загрузки</h6>
                <p class="text-muted">Не удалось загрузить уведомления</p>
            </div>`;
    }
}

async function markAllNotificationsRead() {
    if (!currentUserId) return;
    const token = localStorage.getItem('access_token');
    try {
        await markAllNotificationsRead(currentUserId, token);
        await loadNotifications(); // Обновить список
        alert('Все уведомления отмечены как прочитанные');
    } catch (error) {
        console.error('Mark read error:', error);
        alert('Ошибка при отметке уведомлений');
    }
}

```

### web\js\projects.js

```js```
// web/js/projects.js
// import { getProjects, createProject } from './api.js'; // Если используем ES6 modules

async function loadProjects() {
    if (!currentUserId) {
        document.getElementById('projects-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-exclamation-triangle fa-2x text-muted mb-3"></i>
                <h6>Необходима авторизация</h6>
                <p class="text-muted">Для просмотра проектов войдите в систему</p>
            </div>`;
        return;
    }
    const token = localStorage.getItem('access_token');
    try {
        const data = await getProjects(currentUserId, token); // Предполагаем, что getProjects определена в api.js или импортирована
        const container = document.getElementById('projects-list');

        if (!data.projects || data.projects.length === 0) {
            container.innerHTML = `
                <div class="max-card text-center">
                    <i class="fas fa-folder-open fa-2x text-muted mb-3"></i>
                    <h6>Проектов пока нет</h6>
                    <p class="text-muted">Создайте свой первый проект!</p>
                    <button class="btn max-btn-primary" onclick="createProject()"><i class="fas fa-plus"></i> Создать проект</button>
                </div>`;
            return;
        }

        container.innerHTML = data.projects.map(member => {
            const project = member.project;
            const stats = project.stats || { tasks_count: 0, tasks_done: 0 };
            const progress = stats.tasks_count > 0 ? Math.round((stats.tasks_done / stats.tasks_count) * 100) : 0;
            return `
                <div class="project-card max-card" onclick="openProject('${project.hash}')">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h6 class="mb-0">${project.title}</h6>
                        <span class="badge bg-${member.role === 'owner' ? 'primary' : 'secondary'}">${member.role}</span>
                    </div>
                    <p class="text-muted mb-1">${project.description || 'Без описания'}</p>
                    <div class="d-flex justify-content-between align-items-center">
                        <small class="text-muted">Участников: ${project.members ? project.members.length : 0}</small>
                        <small class="text-muted">Задач: ${stats.tasks_count}</small>
                    </div>
                    <div class="progress mt-2" style="height: 8px;">
                        <div class="progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <small class="text-muted">${progress}% завершено</small>
                </div>`;
        }).join('');

    } catch (error) {
        console.error('Projects load error:', error);
        document.getElementById('projects-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-exclamation-triangle fa-2x text-muted mb-3"></i>
                <h6>Ошибка загрузки</h6>
                <p class="text-muted">Не удалось загрузить проекты</p>
            </div>`;
    }
}

async function createProject() {
    if (!currentUserId) {
        alert('Необходима авторизация для создания проекта');
        return;
    }
    const title = prompt('Введите название проекта:');
    if (!title) return;
    const description = prompt('Введите описание проекта (необязательно):') || '';

    const token = localStorage.getItem('access_token');
    try {
        const result = await createProject(title, description, token); // Предполагаем, что createProject определена в api.js или импортирована
        alert(`Проект "${result.project.title}" создан!`);
        if (currentSection === 'projects') {
            await loadProjects();
        }
        await loadDashboardData(); // Обновить счётчики
    } catch (error) {
        console.error('Project creation error:', error);
        alert('Ошибка при создании проекта: ' + error.message);
    }
}

function openProject(projectHash) {
    // Здесь можно открыть модальное окно с деталями проекта или перейти на страницу проекта
    // Пока просто покажем QR-код для приглашения
    showProjectInviteQR(projectHash);
}

function showProjectInviteQR(projectHash) {
    const inviteUrl = `${window.location.origin}/?join=${projectHash}`;
    const modal = new bootstrap.Modal(document.createElement('div'));
    const modalHTML = `
        <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Пригласить в проект</h5>
                        <button type="button" class="btn-close" onclick="this.closest('.modal').remove()"></button>
                    </div>
                    <div class="modal-body text-center">
                        <p>Отправьте этот QR-код пользователю:</p>
                        <div id="qrCodeContainer"></div>
                        <p class="mt-2">Или поделитесь ссылкой: <code>${inviteUrl}</code></p>
                    </div>
                </div>
            </div>
        </div>`;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    const modalElement = document.querySelector('.modal.show');
    new QRCode(document.getElementById('qrCodeContainer'), { text: inviteUrl, width: 200, height: 200 });
    modalElement.querySelector('.btn-close').addEventListener('click', () => modalElement.remove());
}

```

### web\js\tasks.js

```js```
// web/js/tasks.js
// import { getTasks, getProjectTasks, updateTaskStatus } from './api.js'; // Если используем ES6 modules

let currentTaskId = null;
let currentTaskDetails = null;
let taskSearchFuse = null;

async function loadTasks(status = null) {
    if (!currentUserId) {
        document.getElementById('tasks-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-tasks fa-2x text-muted mb-3"></i>
                <h6>Необходима авторизация</h6>
                <p class="text-muted">Для просмотра задач войдите в систему</p>
            </div>`;
        return;
    }
    const token = localStorage.getItem('access_token');
    try {
        const data = await getTasks(currentUserId, token); // Предполагаем, что getTasks определена в api.js или импортирована
        const tasks = data.tasks || [];

        // Фильтрация по статусу
        const filteredTasks = status ? tasks.filter(t => t.status === status) : tasks;

        const container = document.getElementById('tasks-list');
        if (filteredTasks.length === 0) {
            container.innerHTML = `
                <div class="max-card text-center">
                    <i class="fas fa-tasks fa-2x text-muted mb-3"></i>
                    <h6>Задач пока нет</h6>
                    <p class="text-muted">Создайте первую задачу в проекте!</p>
                </div>`;
            return;
        }

        container.innerHTML = filteredTasks.map(task => {
            const statusColor = getStatusColor(task.status); // Предполагаем, что функция определена в main.js или utils.js
            const statusText = getStatusText(task.status); // Предполагаем, что функция определена в main.js или utils.js
            return `
                <div class="task-item task-${task.status} max-card" onclick="openTaskModal(${task.id})">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <h6 class="mb-0">${task.title}</h6>
                            <p class="text-muted small mb-1">${task.description ? task.description.substring(0, 50) + '...' : ''}</p>
                            <div class="d-flex align-items-center">
                                <span class="badge bg-${statusColor} me-2">${statusText}</span>
                                <span class="text-muted small">${formatDate(task.created_at)}</span>
                            </div>
                        </div>
                        <div class="text-end">
                            <div class="text-muted small">Проект: ${task.project.title}</div>
                            <div class="text-muted small">Приоритет: ${task.priority}</div>
                        </div>
                    </div>
                </div>`;
        }).join('');

        // Инициализация поиска
        taskSearchFuse = new Fuse(tasks, {
            keys: ['title', 'description'],
            threshold: 0.3
        });

    } catch (error) {
        console.error('Tasks load error:', error);
        document.getElementById('tasks-list').innerHTML = `
            <div class="max-card text-center">
                <i class="fas fa-exclamation-triangle fa-2x text-muted mb-3"></i>
                <h6>Ошибка загрузки</h6>
                <p class="text-muted">Не удалось загрузить задачи</p>
            </div>`;
    }
}

function openTaskModal(taskId) {
    currentTaskId = taskId;
    // Загрузка деталей задачи и открытие модального окна
    // Пока упрощённо
    const token = localStorage.getItem('access_token');
    fetch(`${API_BASE_URL}/tasks/${taskId}`, {
        headers: { 'Authorization': `Bearer ${token}` }
    })
    .then(response => response.json())
    .then(data => {
        currentTaskDetails = data.task;
        document.getElementById('taskModalTitle').textContent = data.task.title;
        document.getElementById('taskModalProjectTitle').textContent = data.task.project.title;
        document.getElementById('taskModalDescription').textContent = data.task.description || '';
        document.getElementById('taskModalStatus').value = data.task.status;

        // Заполнение assignees
        const assigneeSelect = document.getElementById('taskModalAssignees');
        assigneeSelect.innerHTML = '';
        data.task.project.members.forEach(member => {
            const option = document.createElement('option');
            option.value = member.user_id;
            option.textContent = member.user.full_name;
            if (data.task.assigned_to_id === member.user_id) option.selected = true;
            assigneeSelect.appendChild(option);
        });

        // Заполнение подзадач
        const subtasksContainer = document.getElementById('taskModalSubtasks');
        subtasksContainer.innerHTML = data.task.subtasks ? data.task.subtasks.map(st => `
            <div class="form-check">
                <input class="form-check-input" type="checkbox" value="" id="subtask${st.id}" ${st.status === 'done' ? 'checked' : ''} disabled>
                <label class="form-check-label" for="subtask${st.id}">${st.title}</label>
            </div>
        `).join('') : '';

        // Заполнение комментариев
        const commentsContainer = document.getElementById('taskModalComments');
        commentsContainer.innerHTML = data.task.comments ? data.task.comments.map(c => `
            <div class="comment-item mb-2">
                <strong>${c.user.full_name}</strong> <small class="text-muted">${formatDate(c.created_at)}</small>
                <p class="mb-1">${escapeHTML(c.content)}</p>
            </div>
        `).join('') : '';

        // Заполнение файлов
        const filesContainer = document.getElementById('taskModalFiles');
        filesContainer.innerHTML = data.task.attachments ? data.task.attachments.map(att => `
            <a href="${att.url}" target="_blank">${att.filename}</a>
        `).join('<br>') : 'Нет прикреплённых файлов';

        const modal = new bootstrap.Modal(document.getElementById('taskModal'));
        modal.show();
    })
    .catch(err => console.error('Error loading task details:', err));
}

function updateTask() {
    if (!currentUserId || !currentTaskId) return;
    const token = localStorage.getItem('access_token');
    const newStatus = document.getElementById('taskModalStatus').value;
    updateTaskStatus(currentTaskId, newStatus, token) // Предполагаем, что updateTaskStatus определена в api.js или импортирована
        .then(() => {
            alert('Задача обновлена!');
            const modal = bootstrap.Modal.getInstance(document.getElementById('taskModal'));
            modal.hide();
            if (currentSection === 'tasks') {
                loadTasks(); // Перезагрузить задачи
            }
        })
        .catch(err => {
            console.error('Update task error:', err);
            alert('Ошибка обновления задачи');
        });
}

function debounceSaveTaskDescription() {
    debounce(async () => { // Предполагаем, что debounce определена в main.js или utils.js
        if (!currentTaskId) return;
        const newDesc = document.getElementById('taskModalDescription').textContent;
        // Реализовать PUT запрос для обновления описания
        // PUT /api/tasks/{id}/description
        // console.log('Saving description for task', currentTaskId, ':', newDesc);
    }, 500)();
}

function addSubtask() {
    const title = prompt('Введите название подзадачи:');
    if (title) {
        // Реализовать POST запрос для создания подзадачи
        // POST /api/tasks/
        // console.log('Adding subtask:', title, 'to task', currentTaskId);
    }
}

function addComment() {
    const text = document.getElementById('newCommentText').value.trim();
    if (!text) return;
    // Реализовать POST запрос для создания комментария
    // POST /api/tasks/{id}/comments
    // console.log('Adding comment:', text, 'to task', currentTaskId);
    document.getElementById('newCommentText').value = '';
}

function searchTasks() {
    const query = document.getElementById('searchTasksInput').value;
    if (!taskSearchFuse || !query) {
        loadTasks(); // Показать все задачи, если нет запроса
        return;
    }
    const results = taskSearchFuse.search(query);
    const container = document.getElementById('tasks-list');
    if (results.length === 0) {
        container.innerHTML = '<p class="text-muted">Задачи не найдены.</p>';
        return;
    }
    container.innerHTML = results.map(result => {
        const task = result.item;
        const statusColor = getStatusColor(task.status); // Предполагаем, что функция определена в main.js или utils.js
        const statusText = getStatusText(task.status); // Предполагаем, что функция определена в main.js или utils.js
        return `
            <div class="task-item task-${task.status} max-card" onclick="openTaskModal(${task.id})">
                <div class="d-flex justify-content-between align-items-start">
                    <div class="flex-grow-1">
                        <h6 class="mb-0">${task.title}</h6>
                        <p class="text-muted small mb-1">${task.description ? task.description.substring(0, 50) + '...' : ''}</p>
                        <div class="d-flex align-items-center">
                            <span class="badge bg-${statusColor} me-2">${statusText}</span>
                            <span class="text-muted small">${formatDate(task.created_at)}</span>
                        </div>
                    </div>
                    <div class="text-end">
                        <div class="text-muted small">Проект: ${task.project.title}</div>
                        <div class="text-muted small">Приоритет: ${task.priority}</div>
                    </div>
                </div>
            </div>`;
    }).join('');
}

```

